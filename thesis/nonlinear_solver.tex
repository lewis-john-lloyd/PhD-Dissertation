\chapter{Nonlinear \cobra{}}
\label{chap:nln_solver}
The basic \cobra{} software utilized the traditional single Newton step of the semi-implicit method.
In order to investigate the effects of nonlinear convergence upon the determination of the temporal convergence for a given solution, \cobra{} was modified to enable an iterative global Newton's method.
Several algorithmic problems were identified and resolved during this work.
For effective use of the nonlinear solver, a meaningful convergence metric was required for termination of the Newton solver.
A physics based scaling method was developed to provide a physically meaningful convergence metric.
To aid in the identification of temporally converged converged solutions, a metric was developed.

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\section{Linear Solution Algorithm}
\label{sect:lin_cobra_alg}

\cobra{} utilizes the semi-implicit method as outlined in \sect{subsect:semi_implicit}.
A detailed description of the solution algorithm as implemented will be presented in the following section.
First, the exact discrete algebraic equations will be laid out in pedantic detail because this seems to be standard practice.
The momentum equations, neglecting spatial discretization notation and external sources, are given in \eqref{eqn:si_mom_liq} -- \eqref{eqn:si_mom_ent}.

\begin{IEEEeqnarray}{rCl}
\label{eqn:si_mom_liq}
\dot{m}_{l}^{n+1} - \dot{m}_{l}^{n} & = & \frac{\Delta t}{\Delta x}\left(- \sum_{NK} \left( (\alpha_l \rho_l u_l) u_l \cdot \vec{\bar{A}}\right)^{n}
 -\alpha^{n}_l \nabla P^{n+1} + (\alpha_l \rho_l)^{n} g - K^{n}_{wl}(\dot{m}_l^{n+1})^2 \right. \nonumber \\
 & + & \left. K^{n}_{i,gl}(\dot{m}^{n+1}_l - \dot{m}_g^{n+1})^2 - ((1 - \eta)\Gamma u^{'})^{n} - (S u^{'})^{n}\vphantom{\sum_{NK}}\right) \\
\label{eqn:si_mom_gas}
\dot{m}_{g}^{n+1} - \dot{m}_{g}^{n} & = & \frac{\Delta t}{\Delta x}\left(- \sum_{NK} \left( (\alpha_g \rho_g u_g) u_g  \cdot \vec{\bar{A}}\right)^{n}  -\alpha^{n}_g \nabla P^{n+1} + (\alpha_g \rho_g)^{n} g - K^{n}_{wg}(\dot{m}_g^{n+1})^2 \right.\nonumber \\
& - & \left. K^{n}_{i,gl}(\dot{m}^{n+1}_l - \dot{m}_g^{n+1})^2 -K^{n}_{i,ge}(\dot{m}^{n+1}_e - \dot{m}_g^{n+1})^2 + (\Gamma u^{'})^{n}\vphantom{\sum_{NK}}\right) \\
\label{eqn:si_mom_ent}
\dot{m}_{e}^{n+1} - \dot{m}_{e}^{n} & = & \frac{\Delta t}{\Delta x}\left(- \sum_{NK} \left( (\alpha_e \rho_l u_e) u_e  \cdot \vec{\bar{A}}\right)^n -\alpha^{n}_e \nabla P^{n+1} + (\alpha_e \rho_l)^{n} g - K^{n}_{we}(\dot{m}_e^{n+1})^2\right. \nonumber \\
&+& \left. K^{n}_{i,ge}(\dot{m}^{n+1}_e - \dot{m}_g^{n+1})^2 - (\eta \Gamma u^{'})^{n} + (S u^{'})^n\vphantom{\sum_{NK}}\right)
\end{IEEEeqnarray}

In the above equations the flux terms are summed over $NK$, which indicates the number of continuity volumes connected to a given momentum volume.
The coefficients $K$ represent effective friction factors calculated using parameters only from time n.
The interfacial transfer terms are explicitly evaluated.
The only new-time parameters used in \eqref{eqn:si_mom_liq} -- \eqref{eqn:si_mom_ent} are momenta and pressures.
The continuity equations used in this work, omitting external sources, are shown in \eqref{eqn:si_mass_ncg} -- \eqref{eqn:si_nrg_liq}.

\begin{IEEEeqnarray}{rCl}
\label{eqn:si_mass_ncg}
V_c (\alpha_g \rho_{n})^{n+1} & - & V_c (\alpha_g \rho_{n})^{n} = -\Delta t \sum_{NK}\left( \don{\alpha^{n}_g \rho^{n}_{n}}^{n}_{d} u^{n+1}_g  \cdot \vec{\bar{A}}\right) \\
\label{eqn:si_mass_vap}
V_c \left(\alpha_g \rho_v \right)^{n+1} &-& V_c \left(\alpha_g \rho_v \right)^{n} = - \Delta t \sum_{NK} \left( \don{\alpha^{n}_g \rho^{n}_v}^{n}_{d} u^{n+1}_g  \cdot \vec{\bar{A}}\right) + \Delta t \Gamma^{n+1} \\
\label{eqn:si_mass_liq}
V_c \left(\alpha_l \rho_l \right)^{n+1} & - & V_c \left(\alpha_l \rho_l \right)^{n} =  -\Delta t \sum_{NK}\left( \don{\alpha^n_l \rho^n_l}^{n}_{d} u^{n+1}_l  \cdot \vec{\bar{A}}\right) \nonumber \\
&- &\Delta t\left[(1-\eta)\Gamma + S \right]^{n+1} \\
\label{eqn:si_mass_ent}
V_c \left(\alpha_e \rho_l \right)^{n+1} & - & V_c \left(\alpha_e \rho_l \right)^{n} = -\Delta t \sum_{NK}\left( \don{\alpha^{n}_e \rho^{n}_l}^{n}_{d} u^{n+1}_e  \cdot \vec{\bar{A}}\right)\nonumber \\ 
&+& \Delta t\left[ S -\eta\Gamma \right]^{n+1} \\
\label{eqn:si_nrg_gas}
V_c \left( \alpha_g \{\rho_g h_g\} \right)^{n+1} & - & V_c \left( \alpha_g \{\rho_g h_g\} \right)^{n}  = -\Delta t \sum_{NK} \left(  \don{\alpha^{n}_g \{\rho_g h_g\}^{n}}^{n}_{d} u^{n+1}_g  \cdot \vec{\bar{A}}\right) \nonumber \\
&+& \Delta t \left[\Gamma h^{'}_v + q_{i,v} + q_{gl} + q_{wg} \right]^{n+1} + V_c \alpha^{n}_g ( P^{n+1} - P^{n} ) \\
\label{eqn:si_nrg_liq}
V_c\left( \alpha_l \rho_l h_l \right)^{n+1} & - & V_c\left( \alpha_l \rho_l h_l \right)^{n} =  -\Delta t \sum_{NK} \left( \don{\alpha^{n}_l \rho^{n}_l h^{n}_l}^{n}_{d} u^{n+1}_l \cdot \vec{\bar{A}} + \don{\alpha^{n}_e \rho^{n}_l h^{n}_l}^{n}_{d} u^{n+1}_e  \cdot \vec{\bar{A}}\right) \nonumber \\
& +& \Delta t \left[q_{wl} -\Gamma h^{'}_l +  q_{i,l} - q_{gl}\right]^{n+1} + V_c \alpha^{n}_l (P^{n+1} - P^{n})
\end{IEEEeqnarray}

\alg{alg:si_legacy} shows the traditional algorithm.
Due to the nature of the semi-implicit method, step 5 of \alg{alg:si_legacy} requires additional details.
The linear algebra problem to be solved during step 5 is presented in \eqref{eqn:si_solve} for a simply connected problem with three continuity volumes and three momentum volumes.

 \begin{equation}
 \label{eqn:si_solve}
 \begin{bmatrix} 
 \vec{J}_{m_1} & \vec{J}_{m_1,c_1} & \vec{0} & \vec{0} & \vec{0} & \vec{0}\\
 \vec{J}_{c_1,m_1} & \vec{J}_{c_1} & \vec{J}_{c_1,m_2} & \vec{0} & \vec{0} & \vec{0} \\
 \vec{0} & \vec{J}_{m_2,c_1} & \vec{J}_{m_2} & \vec{J}_{m_2,c_2} & \vec{0} & \vec{0} \\
 \vec{0} & \vec{0} & \vec{J}_{c_2,m_2} & \vec{J}_{c_2} & \vec{J}_{c_2,m_3} & \vec{0} \\
 \vec{0} & \vec{0} & \vec{0} & \vec{J}_{m_3,c_2} & \vec{J}_{m_3} & \vec{J}_{m_3,c_3} \\ 
 \vec{0} & \vec{0} & \vec{0} & \vec{0} & \vec{J}_{c_3,m_3} & \vec{J}_{c_3}  
 \end{bmatrix} \begin{bmatrix}
 \vec{\delta m}_{1} \\ \vec{\delta c}_{1} \\
 \vec{\delta m}_{2} \\ \vec{\delta c}_{2} \\
 \vec{\delta m}_{3} \\ \vec{\delta c}_{3}
\end{bmatrix}  = -\begin{bmatrix}
 \vec{F}_{m_1} \\ \vec{F}_{c_1} \\
 \vec{F}_{m_2} \\ \vec{F}_{c_2} \\
 \vec{F}_{m_3} \\ \vec{F}_{c_3} \end{bmatrix}
 \end{equation}
 
 The semi-implicit solution framework is composed of five steps.
 First, the momentum volume equations, rows one, three, and five of the linear system \eqref{eqn:si_solve}, are multiplied by their inverse diagonal Jacobian entries, $\vec{J}_{m_k}$.
 The off-diagonal entries for the momentum equations are now $\vec{J}^{-1}_{m_k}\vec{J}_{m_k,c_j}$ where $j$ is the index of the connected continuity volumes.
 Since the $J_{m_k,c_j}$ terms only contain derivatives with respect to the pressure for the adjoining continuity volumes, the [3 x 6] matrix product $\vec{J}^{-1}_{m_k}\vec{J}_{m_k,c_j}$ will be referred to as $\frac{\partial \vec{m}_k}{\partial P_j}$.
 This product matrix only contains entries in the sixth column.
 Using the above notation, the resulting system is given in \eqref{eqn:si_solve_1}.
 
  \begin{equation}
 \label{eqn:si_solve_1}
 \begin{bmatrix} 
 \vec{I} & \frac{\partial \vec{m}_1}{\partial P_1} & \vec{0} & \vec{0} & \vec{0} & \vec{0}\\
 \vec{J}_{c_1,m_1} & \vec{J}_{c_1} & \vec{J}_{c_1,m_2} & \vec{0} & \vec{0} & \vec{0} \\
 \vec{0} & \frac{\partial \vec{m}_2}{\partial P_1} & \vec{I} & \frac{\partial \vec{m}_2}{\partial P_2} & \vec{0} & \vec{0} \\
 \vec{0} & \vec{0} & \vec{J}_{c_2,m_2} & \vec{J}_{c_2} & \vec{J}_{c_2,m_3} & \vec{0} \\
 \vec{0} & \vec{0} & \vec{0} & \frac{\partial \vec{m}_{3}}{\partial P_2} & \vec{I} & \frac{\partial \vec{m}_{3}}{\partial P_3} \\ 
 \vec{0} & \vec{0} & \vec{0} & \vec{0} & \vec{J}_{c_3,m_3} & \vec{J}_{c_3}  
 \end{bmatrix} \begin{bmatrix}
 \vec{\delta m}_{1} \\ \vec{\delta c}_{1} \\
 \vec{\delta m}_{2} \\ \vec{\delta c}_{2} \\
 \vec{\delta m}_{3} \\ \vec{\delta c}_{3}
\end{bmatrix}  = -\begin{bmatrix}
 \vec{J}^{-1}_{m_1}\vec{F}_{m_1} \\ \vec{F}_{c_1} \\
 \vec{J}^{-1}_{m_2}\vec{F}_{m_2} \\ \vec{F}_{c_2} \\
 \vec{J}^{-1}_{m_3}\vec{F}_{m_3} \\ \vec{F}_{c_3} \end{bmatrix}
 \end{equation}

Second, the momentum equations are used to eliminate the $\vec{J}_{c_k,m_k}$ entries from the continuity volumes.
The resulting equation set, \eqref{eqn:si_solve_2}, no longer has equations for the momentum volumes.

\begin{IEEEeqnarray}{rl}
\label{eqn:si_solve_2}
\begin{bmatrix} 
\vec{J}_{c_1} - \vec{J}_{c_1,m_1}\frac{\partial \vec{m}_1}{\partial P_1} - \vec{J}_{c_1,m_2}\frac{\partial \vec{m}_2}{\partial P_1} &
-\vec{J}_{c_1,m_2}\frac{\partial \vec{m}_2}{\partial P_2} &
\vec{0} \\
-\vec{J}_{c_2,m_2}\frac{\partial \vec{m}_2}{\partial P_1} & 
\vec{J}_{c_2} - \vec{J}_{c_2,m_2}\frac{\partial \vec{m}_2}{\partial P_2}-\vec{J}_{c_2,m_3}\frac{\partial \vec{m}_3}{\partial P_2} &
-\vec{J}_{c_2,m_3}\frac{\partial \vec{m}_3}{\partial P_3} \\
 \vec{0} &
-\vec{J}_{c_3,m_3}\frac{\partial \vec{m}_3}{\partial P_2} &
\vec{J}_{c_3} -\vec{J}_{c_3,m_3}\frac{\partial \vec{m}_3}{\partial P_3} 
\end{bmatrix} &\begin{bmatrix}
\vec{\delta c}_{1} \\
\vec{\delta c}_{2} \\
\vec{\delta c}_{3}
\end{bmatrix} \nonumber \\
 = -\begin{bmatrix}
\vec{F}_{c_1} -
\vec{J}_{c_1,m_1}\vec{J}^{-1}_{m_1}\vec{F}_{m_1}-\vec{J}_{c_1,m_2}\vec{J}^{-1}_{m_2}\vec{F}_{m_2} \\
\vec{F}_{c_2} - 
\vec{J}_{c_2,m_2}\vec{J}^{-1}_{m_2}\vec{F}_{m_2}-\vec{J}_{c_2,m_3}\vec{J}^{-1}_{m_3}\vec{F}_{m_3} \\
\vec{F}_{c_3} - 
\vec{J}_{c_3,m_3}\vec{J}^{-1}_{m_3}\vec{F}_{m_3}
\end{bmatrix} &
 \end{IEEEeqnarray}

The off-diagonal entries of the reduced Jacobian matrix in \eqref{eqn:si_solve_2}, $\vec{J}_{c_i,m_j}\frac{\partial \vec{m}_j}{\partial P_k}$ will be denoted by $\vec{C}_{c_i,P_j}$ as they represent the change in the continuity variables in volume $i$ due to the change in the pressure of continuity volume $j$.
The [6 x 6] matrix, $\vec{C}_{c_i,P_j}$, contains only entries in the last column, which correspond to the inter-continuity pressure coupling terms.
The diagonal entries of the reduced Jacobian and the right-hand side entries will be referred to as $\vec{J}^{*}_{c_i}$ and $\vec{F}^{*}_{c_i}$.
With this new nomenclature, \eqref{eqn:si_solve_2} can be restated as \eqref{eqn:si_solve_3}.

  \begin{equation}
 \label{eqn:si_solve_3}
 \begin{bmatrix} 
 \vec{J}^{*}_{c_1} & \vec{C}_{c_1,P_2} & \vec{0} \\
 \vec{C}_{c_2,P_1} & \vec{J}^{*}_{c_2} & \vec{C}_{c_2,P_3} \\
 \vec{0}           & \vec{C}_{c_3,P_2} & \vec{J}^{*}_{c_3}
 \end{bmatrix} \begin{bmatrix}
 \vec{\delta c}_{1} \\
 \vec{\delta c}_{2} \\
 \vec{\delta c}_{3}
\end{bmatrix}  = -\begin{bmatrix}
 \vec{F}^{*}_{c_1} \\
 \vec{F}^{*}_{c_2} \\
 \vec{F}^{*}_{c_3}
\end{bmatrix}
 \end{equation}

Step three is to multiply each row by the $\vec{L}^{-1}_{c_i}$ portion of the LU decomposition without pivoting of $\vec{J}^{*}_{c_i}$, \eqref{eqn:si_solve_4}

  \begin{equation}
 \label{eqn:si_solve_4}
 \begin{bmatrix} 
 \vec{U}^{*}_{c_1} & \vec{L}^{-1}_{c_1}\vec{C}_{c_1,P_2} & \vec{0} \\
 \vec{L}^{-1}_{c_2}\vec{C}_{c_2,P_1} & \vec{U}^{*}_{c_2} & \vec{L}^{-1}_{c_2}\vec{C}_{c_2,P_3} \\
 \vec{0}           & \vec{L}^{-1}_{c_3}\vec{C}_{c_3,P_2} & \vec{U}^{*}_{c_3}
 \end{bmatrix} \begin{bmatrix}
 \vec{\delta c}_{1} \\
 \vec{\delta c}_{2} \\
 \vec{\delta c}_{3}
\end{bmatrix}  = -\begin{bmatrix}
 \vec{L}^{-1}_{c_1}\vec{F}^{*}_{c_1} \\
 \vec{L}^{-1}_{c_2}\vec{F}^{*}_{c_2} \\
 \vec{L}^{-1}_{c_3}\vec{F}^{*}_{c_3}
\end{bmatrix}
 \end{equation}
 
By isolating the last row from each continuity block and dividing that row by its diagonal entry, a resulting matrix for the pressure update in every continuity volume is obtained, \eqref{eqn:si_pressure_matrix}. 
For a problem with $N$ continuity volumes, the resulting pressure matrix, \eqref{eqn:si_pressure_matrix}, will be $N$ x $N$.
For the simple geometry considered in this example, the resultant pressure matrix is a tridiagonal matrix.
However, this is not the case for more complex geometries.

  \begin{equation}
 \label{eqn:si_pressure_matrix}
 \begin{bmatrix} 
 1 & \frac{\vec{L}^{-1}_{c_1}\vec{C}_{c_1,P_2}[6]}{\vec{U}^{*}_{c_1}[6]} & \vec{0} \\
 \frac{\vec{L}^{-1}_{c_2}\vec{C}_{c_2,P_1}[6]}{\vec{U}^{*}_{c_2}[6]} & 1 & \frac{\vec{L}^{-1}_{c_2}\vec{C}_{c_2,P_3}[6]}{\vec{U}^{*}_{c_2}[6]} \\
 \vec{0}           & \frac{\vec{L}^{-1}_{c_3}\vec{C}_{c_3,P_2}[6]}{\vec{U}^{*}_{c_3}[6]} & 1
 \end{bmatrix} \begin{bmatrix}
 \vec{\delta P}_{1} \\
 \vec{\delta P}_{2} \\
 \vec{\delta P}_{3}
\end{bmatrix}  = -\begin{bmatrix}
 \frac{\vec{L}^{-1}_{c_1}\vec{F}^{*}_{c_1}[6]}{\vec{U}^{*}_{c_1}[6]} \\
 \frac{\vec{L}^{-1}_{c_2}\vec{F}^{*}_{c_2}[6]}{\vec{U}^{*}_{c_2}[6]} \\
 \frac{\vec{L}^{-1}_{c_3}\vec{F}^{*}_{c_3}[6]}{\vec{U}^{*}_{c_3}[6]}
\end{bmatrix}
 \end{equation}

In step four, the pressure matrix is then solved for the pressure updates in every continuity volume.
This step is performed using either the sparse-matrix solver, SuperLU \cite{Li1999} or direct Gaussian elimination. 

Step five is to use the vector of pressure updates to obtain the continuity updates in every volume from \eqref{eqn:si_solve_4} and to obtain the updates for the momentum variables from the momentum rows of \eqref{eqn:si_solve_1}.

This five-step process provides an overview of the solution technique of the semi-implicit method used in \cobra{}.
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\section{Nonlinear Solution Algorithm}
\label{sect:nln_cobra_alg}
As obtained, the \cobra{} software used a single-shot linearization of the semi-implicit method.
In order to evaluate the subdomain nonlinear refinement algorithm, \cobra{} needed to be modified to include a fully iterative Newton solver based upon a line search globalization strategy.
As part of the \cobra{} modification a novel operator-based scaling has been developed to obtain meaningful convergence thresholds.
When it is necessary to distinguish between the single-shot linearization algorithmic implementation of \cobra{} and the iterative nonlinear \cobra{} implementation, the former shall be referred to as the linear solver and the latter as the nonlinear solver.
As such, the \cobra{} software needed to be modified to be able do the following:

\begin{itemize}
\item{Create a data framework for constructing vector quantities such as $\vec{x}^{k}$ and $\vec{F}$.}
\item{Correctly evaluate $\vec{F}(\vec{x}^{k})$ and $\vec{J}(x^{k})$.}
\item{Develop proper scaling of $\vec{F}(\vec{x}^{k})$.}
\item{Implement a globalization strategy for Newton's method.}
\end{itemize}

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\section{Algorithmic Considerations}
\label{sect:nln_algo_con}

The methods outlined in \sect{sect:solution_techniques} have several algorithmic issues that need to be addressed.
Among these issues are phase appearance and disappearance (hereafter referred to as phase transition), timestep solution acceptance criteria, and timestep size selection.

Given that the governing conservation laws in thermal-hydraulic analyses are those of two-phase flow, phase transition is integral to accurate simulations.
The methods for addressing phase transitions within two-phase analysis software are ad hoc procedures that vary from software to software.
While each algorithmic implementation of the various methods addresses this issue out of necessity, there is no systematic or optimal way of doing so.
However, certain physical limits have been identified that need to be considered \cite{Bestion2000}.

When the two-phase flow within \cobra{} approaches that of single-phase flow, there is a lower limit imposed upon the volume fraction of the phase that is disappearing.
This means that \cobra{} does not transition between the two-phase flow governing equations and the governing equations for single-phase flow.
Even during simulated single-phase flow, the non-dominant phase is still present, but it is at a very small volume fraction.
However, since the \ncgs{} and the vapor fields share a common volume fraction, the partial pressure of the \ncgs{} is allowed to go to zero. 
Since \cobra{} incorporates two liquid fields, the lower limit for the aggregate liquid volume fraction, $\alpha_e + \alpha_l$, is equally divided between the two liquid fields.
As a phase approaches depletion, $\alpha_k \rightarrow \alpha_{k,\text{MIN}}$, the velocity of the depleting phase is required to approach that of the remaining phase.
This velocity equilibrium is imposed by artificially increasing the interfacial drag between the two phases.

Upon completion of a timestep within \cobra{}, there are certain constraints that are imposed upon the independent parameters.
These constraints are designed to deal with the possibility that the obtained solution may not be an accurate one.
After the single Newton step, the updated parameters are evaluated to determine their validity.
There are two ways of resolving potentially invalid solutions: parameter limiting and timestep failure.
The limiting procedure can either truncate the updated parameter so that it falls within a valid range, or the timestep can be considered a failure.
When a predicted volume fraction falls outside of its valid range, it is truncated to obey the constraint of equation \eqref{eqn:volume_fraction}.

\begin{equation}
\label{eqn:volume_fraction}
\alpha_{k,\text{min}} \leq \alpha_k \leq \alpha_{k,\text{max}} 
\end{equation}

There are also limits placed upon the changes of the thermodynamic parameters within a timestep in \cobra{}.
The constrained thermodynamic parameters and the limits imposed upon their per-timestep changes are listed below.

\begin{itemize}
\item{Change of phasic enthalpy cannot be greater than 45 [$\frac{\text{BTU}}{\lbm{}}$].}
\item{Change in pressure cannot be greater than 20 [psia].}
\item{Change in partial pressure of the \ncg{} field cannot be greater than 20 [psia].}
\item{Thermodynamic variables would fall outside of the range of validity of the equations of state.}
\end{itemize}

The first three limits are an attempt to mitigate an initial guess that may be outside of the Newton step's radius of convergence.
If any of the above limits are exceeded, the timestep is considered a failure and is repeated with a smaller timestep size.

Another algorithmic concern is how to identify a potentially poor linearization point in the presence of phase transitions. 
This can be considered a predictive error correction technique.
It uses information from the explicit portion of the nonlinear residual to identify situations where the linearization point may be poor.
In \cobra{} this method is used only for the prediction of \ncg{} appearance.

To determine the \dt{} at each timestep \cobra{} uses an adaptive timestep selection algorithm.
This algorithm is based upon a maximum permissible timestep based upon the material Courant limit.
The \dt{} for any timestep is given by \eqref{eqn:time_step}.

\begin{equation}
\label{eqn:time_step}
\Delta t^{n \rightarrow n+1} = \max\left[ \Delta t_{\text{MIN}}, \min\left[1.2 \Delta t^{n-1 \rightarrow n}, 0.85 \Delta t_{\text{CRNT}}, \Delta t_{\text{MAX}} \right]\right]
\end{equation}

$\Delta t_{\text{CRNT}}$ is the most restrictive Courant number calculated for both axial and transverse flow, and a \dt{} that is based upon the time calculated to empty a given volume of the mass of a given field.
The most restrictive of the Courant timestep is used as $\Delta t^{n \rightarrow n+1}$.

\cobra{} utilized a single-shot linearization for its solution technique.
As a result of that design decision, memory saving techniques were employed in the construction of the software that precluded more than one Newton step.
In particular, there was the implicit assumption within the software that the first Newton iterate, $\vec{x}^{n+1, 0}$, was the old-time variable $\vec{x}^{n}$.
This design decision required the vetting of all subroutines involved with the evaluation of the components of both the nonlinear residual and its Jacobian.
In addition, the assumption that $\vec{x}^{n+1, k} = \vec{x}^{n}$ produced source code that was inconsistent with an iterative Newton method.
The source code was modified to reflect the intended discretization of the governing conservation laws.
To do this, areas had to be identified where: there were implicit cancellation of terms, the new-time variables were used in place of old-time variables, and the old-time variables were used in place of new-time variables.
Where appropriate, the software was changed to reflect the distinction between old-time and iterate variables and to introduce terms that had been assumed to be equal to zero.

Once the appropriate variables were used for the evaluation of the nonlinear residuals and the Jacobian, a Newton loop was introduced to allow multiple Newton steps.
\alg{alg:nl_cobra} contains the current algorithmic implementation of the nonlinear semi-implicit method.

\begin{algo}[H]
\setlength{\baselineskip}{0.625\baselineskip}
\begin{algorithmic}[1]
\Require $\vec{x}^{0}$ and $t^{0}$
\Set $n = 0$
\Loop \; Transient Loop
    \State $t^{n+1} : = t^{n} + \Delta t$
    \State $k = 0$
    \Define $\vec{x}^{n+1,0}$
	\Calculate $\vec{F}(\vec{x}^{n+1,0})$ and $\vec{J}(\vec{x}^{n+1,0})$
    \Loop \; Newton Loop
		\Calculate $\vec{\delta x} = - \vec{J}^{-1}\cdot\vec{F}$
		$j = 0$		
		\Calculate $\vec{x}^{n+1,k+1,j}$
		\Calculate $\vec{F}(\vec{x}^{n+1,k+1,j})$
		\Loop \; Globalization Loop
			\If{ Globalization loop termination criteria not met}
				\Calculate $\lambda_j$
				\Calculate $\vec{x}^{n+1,k+1,j+1} = \vec{x}^{n+1,k} + \lambda \vec{\delta x}$
				\Calculate $\vec{F}(\vec{x}^{n+1,k+1,j+1})$
				\State $j = j + 1$			
			\Else
				\Calculate $\vec{J}(\vec{x}^{n+1,k+1,j})$
				\Exit Globalization Loop
			\EndIf
		\EndLoop			
		\If{ Newton loop termination criteria met}
			\Exit Newton Loop
		\EndIf
	\EndLoop
	\State $n = n + 1$
\EndLoop
\end{algorithmic}
\caption{Nonlinear \cobra{} algorithm.}
\label{alg:nl_cobra}
\end{algo}

In \alg{alg:nl_cobra}, there are three steps that require discussion.
First is the Newton Loop termination criteria.
There are three Newton loop termination mechanisms, listed below.

\begin{enumerate}
\item{$k > k_{\,\text{MAX}}$}
\item{$||(\vec{S}^{k+1})^{-1}\vec{F}^{k+1}||_{\infty} \leq F_{\text{ABS}}$}
\item{$||(\vec{D}^{k+1})^{-1}\vec{\delta x}^{k}||_{\infty} \leq \delta_{\text{ABS}}$}
\end{enumerate}

Current values for $k_{\,\text{MAX}}$, $F_{\text{ABS}}$ and $\delta_{\text{ABS}}$ are $35$, $1.0$E$-05$, and $1.0$E$-10$, respectively.
The scaling vectors, $\vec{S}$ and $\vec{D}$, will be addressed later.

The second is the globalization loop termination criteria.
The globalization strategy implemented in \cobra{} is a line search algorithm \cite{Dennis1996}.
The two globalization loop termination criteria are:

\begin{enumerate}
\item{$\frac{1}{2}||\vec{F}^{k+1, j}||^{2}_{2} < \frac{1}{2}||\vec{F}^{k}||^{2}_{2} - \alpha ||\vec{F}^{k}||^{2}_{2}$ }
\item{$||\lambda_{j+1} \vec{\delta x}^{k}||_{\infty} < \delta_{\text{abs}}$}
\end{enumerate}

The third point requiring discussion is the calculation of the Newton update vector.
If neither of the loop termination criteria are met, then a step-length parameter, $\lambda_j$, is calculated.
On the first pass through the globalization loop within a given Newton step, a quadratic backtracking model is adopted.
On subsequent passes, a cubic-backtracking model is used.
 
Since vector forms of the nonlinear residual and the independent parameters are used in determining nonlinear convergence and in the globalization algorithm, they needed to be easily manipulated.
A subroutine was written to gather the discrete variables of the independent parameters into a single vector.
Additional source code modifications were necessary to construct and gather the components of the nonlinear residual.

The development of the nonlinear solver within \cobra{} took place under strict quality assurance guidelines.
At every step of the development, the linear solver was required to maintain the same solution.
This verification was dependent upon a larger number of verification and assessment problems.
The output of the unmodified \cobra{} and the modified \cobra{} software was compared to machine precision.
It was required that either the results of the two simulations be identical or that the reason for the difference be identified and understood.
The \cobra{} software has the ability to repeat a time-step.
As such, it was required that the backup capabilities continued to work while nonlinear solver was being implemented.
Additionally, testing was done to ensure that the ability to restart the software mid-simulation was unaffected.
While adding time to the development cycle, the overhead of the quality assurance procedures ensured that the linear solver could continue to be used for design purposes.

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\section{Operator-Based Scaling}
\label{sect:nln_scaling}
In order to determine the degree to which a state vector, $\vec{x}$, satisfies the governing PDEs, \eqref{eqn:conservation_equations}, the use of the nonlinear residual, $\vec{F})(\vec{x})$, is required.
Due to the units of the residuals for the different conservation equations, the values of the residuals can vary by orders of magnitude.
For a given continuity volume, the nonlinear residual will have six components: four for the conservation of mass and two for the conservation of energy.
For each momentum volume, the three conservation of momentum equations will form the three components of the nonlinear residual.
These residuals have the units of the conserved quantities for their corresponding PDEs; \tab{tab:scaling_units_scales} shows the units for the different conservation equations.

\begin{table}[ht]
\centering
\input{tables/residuals_and_units}
\caption{Residuals and their units.}
\label{tab:scaling_units_scales}
\end{table}

Due to the range of magnitudes of these residuals it is important to choose a proper scaling factor to ensure that the convergence of each equation is relative to their magnitude.
A challenge that has been addressed in this work is the development of a method for scaling of these residuals that is based upon the physics of interest during a timestep.
In constructing this scaling factor it was determined that the following characteristics were desirable:

\begin{itemize}
\item{$(S_{i}^{k})^{-1} F^{k}_i \approx 1$ when $\vec{x}^{k}$ is a "poor" solution.}
\item{$(S_{i}^{k})^{-1} F^{k}_i \rightarrow 0$ when phase $i$ disappears.}
\item{$0 \leq \abs{(S_{i}^{k})^{-1} F^{k}_{i}} \leq 1 $ for all values of $\vec{x}^{k}_i$.}
\end{itemize}

The scaling used in this work is an operator-based approach.
The governing PDEs can be viewed as a collection of operators, both linear and nonlinear, acting upon the vector of independent parameters.
The summation of these operators must balance to zero for the nonlinear equation to be satisfied.

To illustrate the scaling procedure, we shall consider the discrete conservation of continuous liquid mass \eqref{eqn:si_mass_liq}.
The residual for \eqref{eqn:si_mass_liq} would be \eqref{eqn:res_mass_liq}.

\begin{equation}
\label{eqn:res_mass_liq}
F_{m,l} = \Delta t \left[ V_c \frac{\left(\alpha_l \rho_l \right)^{n+1} - \left(\alpha_l \rho_l \right)^{n}}{\Delta t} + \sum_{NK}\left( \don{\alpha^n_l \rho^n_l}^{n}_{d} u^{n+1}_l  \cdot \vec{\bar{A}}\right) + \left[(1-\eta)\Gamma + S \right]^{n+1}\right]
\end{equation}

In this equation there are five physically meaningful quantities: the temporal difference, the mass flowing into  the volume, the mass flowing out of the volume, the mass exchange with the gaseous phase, and the mass exchange with the entrained liquid field.

The scaling chosen for this residual is shown by \eqref{eqn:scaling_factor}.
\begin{equation}
\label{eqn:scaling_factor}
S_{m,l} = \Delta t \left[ V_c \abs{\frac{\left(\alpha_l \rho_l \right)^{n+1} - \left(\alpha_l \rho_l \right)^{n}}{\Delta t}} + \sum_{NK}\abs{\left( \don{\alpha^n_l \rho^n_l}^{n}_{d} u^{n+1}_l  \cdot \vec{\bar{A}}\right)} + \left[\abs{(1-\eta)\Gamma} + \abs{S} \right]^{n+1}\right]
\end{equation}

This scaling creates a relative measure of the nonlinear residual when compared to the magnitude of the physics involved in the process.
The other mass, energy, and momentum equations each have similarly defined scaling factors for their respective residuals.
For convergence testing in the nonlinear version of \cobra{} and residual evaluation during the linear mode, the scaled nonlinear residual is used.

The issue of phase transition was considered during this work.
Since \cobra{} does not actually transition the governing equations to those for single-phase flow, there will always be a nonlinear residual for those phases that are approximately absent.
It was determined that the effects of maintaining a depleted phase in the system of equations when solving the nonlinear problem created a unique issue.
The unscaled residuals would be on the order of machine round-off.
The operator based scaling factors for these residuals would also be within orders of magnitude of machine round-off.
This created the situation where the scaled nonlinear residual for the depleted field would be of $\mathcal{O}$(1).
These depleted residuals would dominate the determination of convergence.
To overcome this deficiency it was determined that when a phase or field began to deplete, the scaling factor would be scaled up to create an artificial decrease in the residual to counter the artificial presence of the depleted field.
This scaling is shown by \eqref{eqn:scaling_factor_small}.

\begin{equation}
\label{eqn:scaling_factor_small}
S_k = \max[1.0, \left(C_1 \frac{\alpha_{k,\text{MIN}}}{\alpha_k}\right)^{C_2} ] S_k
\end{equation}

For this work, the constant $C_1$ was set equal to 100, and the exponent $C_2$ was set equal to 10.
This particular phase transition scaling produced the regular operator scaling factor when the volume fraction of a phase is at least two orders of magnitude greater than the minimum volume fraction for that phase.
This drove the scaled residuals for phases that were nominally not present to zero.
The original coding of \cobra{} has a minimum volume fraction of $\alpha_{k,\text{MIN}}$ = 1.0E-6.
For the work performed here, that value was reduced to $\alpha_{k,\text{MIN}}$ = 1.0E-9.

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\section{Convergence Metric}
\label{sect:temporal_convergence}

An important factor in thermal-hydraulic safety analysis is the temporal convergence of the solution.
A definition for a temporally converged solution is required.
In theory, a temporally converged solution is one where the local truncation error due to the discrete approximation of the temporal integral is orders of magnitude below both the engineering scales of interest and precision of the physical models being used in the simulation.
Unfortunately, the precise measurement of the error in a simulation requires that an analytic solution be available for comparison.
During the simulation of physically realistic systems, there is rarely an analytic solution against which to compare.
This situation requires a slightly different definition of a temporally converged solution --- a definition that does not depend upon accurately measuring the local truncation error.

An alternative definition for temporal convergence could be ``as the timestep size is reduced, the change in the solution is small enough."
While commonly used, this definition is subjective.
Traditionally, ``change in solution" is addressed in a very qualitative manner.
Engineering judgment of which parameters of the solution are of interest is required.
These parameters may include items of regulatory concern such as peak clad temperature or peak system pressure.
Examining only engineering parameters of interest is a weakness.
This locality means that the entire solution domain is not being considered.
Depending upon the context in which the work is being done, the degree of ``small enough" may be nothing more than looking at a graph of the parameter of interest and using engineering judgment to say that ``those two graphs look about the same."
In some cases, a more quantifiable measure may be used.
An example of a quantifiable metric would be if two simulations with different \dtmax{} are classified as dissimilar if the two solutions produce a ``calculated peak fuel cladding temperature different by more than $50\,^{\circ}\mathrm{F}$" \cite{CFR10}.

While it may be that the change in the chosen parameters of interest does not exceed the limits placed upon it as the timestep size is refined, that behavior does not imply that the solution obtained is the solution to the discrete nonlinear problem.
A metric that can quantify the degree to which the obtained solution satisfies the nonlinear system of equations would be of great value.
The previously mentioned work into nonlinear convergence shows that a solution may be timestep size insensitive but not be the converged solution of the discretized problem \cite{Knoll2001}.
If the nonlinearities of the discrete governing equations are not resolved, then the temporal convergence rate can be degraded.
This degradation can produce results that qualitatively appear to be converged due to an almost zeroth order of temporal accuracy.
In practice, the timestep size insensitivity of a solution is often interpreted as temporal convergence.
This apparent temporal convergence, or timestep size insensitivity, of the solution may not be a result of reaching the solution to the discretized nonlinear equations, but instead could be indicative of the degraded order of accuracy due to the failure to resolve the nonlinearities at each timestep.
To determine if the timestep size insensitive transient solution is both timestep size insensitive and an accurate solution to the nonlinear problem, it is necessary to examine the nonlinear convergence of the system as an issue separate from the temporal-convergence.

The norm of the scaled residual from \sect{sect:nln_scaling} provides a well-scaled metric for instantaneous nonlinear convergence at any given time in the simulation.
The residual vector norm is divided by the number of equations in the residual to provide an average residual value per equation.
This equation-averaged scaled residual provides a metric for determining the degree of nonlinear convergence at any timestep in the simulation.
The natural extension of this metric to transient problems would be a temporal integral, \eqref{eqn:trans_res_simple}, of said norm.

\begin{equation}
\label{eqn:trans_res_simple}
R = \int_{t^{0}}^{t^{N}} ||\vec{F}(\tau)||_2 \,\mathrm{d} \tau
\end{equation}

Given the bounds of the scaled residual it was considered desirable to have a similarly scaled transient residual.
The transient residual in \eqref{eqn:trans_res_simple} possesses a dependence upon the number of timesteps taken.
To remove this dependence, a temporal average was instead investigated, \eqref{eqn:trans_res_ave}.

\begin{equation}
\label{eqn:trans_res_ave}
\tilde{R} = \frac{\int_{t^{0}}^{t^{N}} ||\vec{F}(\tau)||_2 \,\mathrm{d} \tau}{t^{N} - t^{0}}
\end{equation}

This metric possesses the desirable bounds $0 \leq R \leq 1$.
Other weighted temporal integrals were considered, such as a simple moment about $t^{0}$, \eqref{eqn:trans_res_mom}.
However, this moment has the disadvantage of weighting the latter portion of the transient greater than the early portion.

\begin{equation}
\label{eqn:trans_res_mom}
\tilde{R}_{\text{M}} = \frac{\int_{t^{0}}^{t^{N}} \,\tau\,||\vec{F}(\tau)||_2 \,\mathrm{d} \tau}{\int_{t^{0}}^{t^{N}} \,\tau \,\mathrm{d} \tau}
\end{equation}