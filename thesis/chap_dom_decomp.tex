\chapter{Domain Decomposition}
\label{chap:domain_decomposition}
The governing partial differential equations described in \sect{subsect:governing_equations} contain nonlinearities that are distributed in both space and time.
In the absence of nonlinear physics a single Newton step is adequate to solve the governing set of discrete algebraic equations.
However, for a given spatial mesh when nonlinearities are present if the number of Newton steps is limited to one, then the only way to resolve those nonlinearities is to refine the temporal discretization.
If the number of Newton steps is not limited to one, then the nonlinearities may be resolved for a fixed temporal discretization.
When the nonlinearities are isolated to a given nonlinear portion of the domain, the additional Newton steps do not improve the solution in the linear portion of the domain.
The ability to resolve the nonlinear physics only where they occur could potentially provide a way to reduce the computational cost associated with resolving the nonlinear error for a given timestep.
The following section contains three sections that describe the mathematical formulation of the domain decomposition, a description of its implementation, and several problems that were used to verify that the algorithm had been implemented properly.

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\section{Mathematical Formulation}
\label{sec:domDecompMath}

With the selective nonlinear refinement algorithm, the domain is split into two segments, a linear domain and a nonlinear domain.
Each continuity volume and momentum volume in the domain is characterized as either existing in the linear domain or the nonlinear domain.
The domain decomposition occurs at the boundary between the linear and the nonlinear domains.
Each momentum volume is associated with a single domain; the momentum equations are not modified, regardless the domain in which the volume exists.
Those volumes which are in the linear domain, but have flowpaths connecting them to the nonlinear domain, are considered to be nonlinear boundary volumes.
All continuity volumes, except these nonlinear boundary volumes, have associated with them the nonlinear continuity equations, \eqref{eqn:nlnNcgMassEquation} -- \eqref{eqn:nlnVapMassEquation}.
Those boundary volumes have modified conservation equations, which will now be discussed.

The starting place for the formulation will be the continuity equations for a generic volume,  \fig{fig:single_volume}.

\begin{figure}[ht!]
\centering
\input{images/isoparametric_volume}
\caption{A single continuity volume.}
\label{fig:single3dvol}
\end{figure}

The edges of the volume will be labeled $x_{j \pm \onehalf}$.
The convention in \cobra{} is that the normal vector for a given volume will be outwards directed.
A positive flow corresponds to flow in the direction of increasing $x_{j}$.
In the normal nonlinear continuity equations, \eqref{eqn:nlnNcgMassEquation} -- \eqref{eqn:nlnVapMassEquation}, the advection terms are formulated in terms new-time velocities and donored quantities evaluated using the new-time velocities.
However, in a nonlinear boundary volume, the flowpath that connects the linear volume to the nonlinear volume is formulated in terms of phasic mass and energy flow rates through the domain interface, \eqref{eqn:massAndEnergyFluxes}.

\begin{equation}
\label{eqn:massAndEnergyFluxes}
\vec{\Psi}^{n+1, k}_{j \pm \onehalf} = \begin{bmatrix}
\Psi_{m, n} \\
\Psi_{m, l} \\
\Psi_{e, g} \\
\Psi_{e, l} \\
\Psi_{m, e} \\
\Psi_{m, v} \\
\end{bmatrix}^{n+1, k}_{j \pm \onehalf}
\end{equation}

This formulation introduces six new unknowns, the flowrates, per domain connection.
The definition of the six flow rates are shown in \eqref{eqn:nbcFluxDefinition}.

\begin{equation}
\label{eqn:nbcFluxDefinition}
\vec{\Psi}^{n+1, k}_{j \pm \onehalf} = \begin{bmatrix}
\frac{\don{\alpha^{n}_{g} \rho^{n}_{n}}^{n+1,k}_{d}}{\ave{\alpha_{g} \rho_{g}}^{n}_{a}}\dot{m}^{n+1,k}_{g} \\
%
\frac{\don{\alpha^{n}_{l}\rho^{n}_{l}}^{n+1,k}_{d}}{\ave{\alpha_{l} \rho_{l}}^{n}_{a}}\dot{m}^{n+1,k}_{l}\\
%
\frac{\don{\alpha^{n}_{g} \rho^{n}_{g} h^{n}_{g}}^{n+1,k}_{d}}{\ave{\alpha_{g} \rho_{g}}^{n}_{a}}\dot{m}^{n+1, k}_{g}\\
%
\frac{\don{\alpha^{n}_{l}\rho^{n}_{l} h^{n}_{l}}^{n+1,k}_{d}}{\ave{\alpha_{l} \rho_{l}}^{n}_{a}}\dot{m}^{n+1, k}_{l} +\frac{\don{\alpha^{n}_{e} \rho^{n}_{l} h^{n}_{l}}^{n+1, k}_{d}}{\ave{\alpha_{e} \rho_{l}}^{n}_{a}}\dot{m}^{n+1, k}_{e} \\
%
\frac{ \don{\alpha^{n}_{e} \rho^{n}_{l}}^{n+1, k}_{d}}{ \ave{\alpha_{e} \rho_{l}}^{n}_{a}} \dot{m}^{n+1, k}_{e} \\
%
\frac{ \don{\alpha^{n}_{g} \rho^{n}_{v}}^{n+1, k}_{d}}{ \ave{\alpha_{g} \rho_{g}}^{n}_{a}} \dot{m}^{n+1, k}_{g}
\end{bmatrix}_{j \pm \onehalf}
\end{equation}

The flow rate vector, $\vec{\Psi}$, can be expressed in matrix form as \eqref{eqn:nbcFluxMatrixStyle}.

\begin{equation}
\label{eqn:nbcFluxMatrixStyle}
\vec{\Psi}^{n+1, k}_{j \pm \onehalf} = \vec{\Xi}^{n+1, k}_{j \pm \onehalf} \cdot \vec{\dot{m}}^{n+1, k}_{j \pm \onehalf}
\end{equation}

The matrix that converts the momentum vector at a continuity volume's edge to mass and energy flows, $\vec{\Xi}$, will be defined by \eqref{eqn:flux_matrix}.

\begin{equation}
\label{eqn:flux_matrix}
\vec{\Xi}^{n+1, k}_{j \pm \onehalf} = \begin{bmatrix}
%
 0 & \frac{\don{\alpha^{n}_{g} \rho^{n}_{n}}^{n+1,k}_{d}}{\ave{\alpha_{g} \rho_{g}}^{n}_{a}} & 0 \\
%
\frac{\don{\alpha^{n}_{l}\rho^{n}_{l}}^{n+1,k}_{d}}{\ave{\alpha_{l} \rho_{l}}^{n}_{a}} & 0 & 0 \\
%
0 & \frac{\don{\alpha^{n}_{g} \rho^{n}_{g} h^{n}_{g}}^{n+1,k}_{d}}{\ave{\alpha_{g} \rho_{g}}^{n}_{a}} & 0 \\
%
\frac{\don{\alpha^{n}_{l}\rho^{n}_{l} h^{n}_{l}}^{n+1,k}_{d}}{\ave{\alpha_{l} \rho_{l}}^{n}_{a}} & 0 & \frac{\don{\alpha^{n}_{e} \rho^{n}_{l} h^{n}_{l}}^{n+1, k}_{d}}{\ave{\alpha_{e} \rho_{l}}^{n}_{a}} \\
%
0 & 0 & \frac{ \don{\alpha^{n}_{e} \rho^{n}_{l}}^{n+1, k}_{d}}{ \ave{\alpha_{e} \rho_{l}}^{n}_{a}} \\
%
0 & \frac{ \don{\alpha^{n}_{g} \rho^{n}_{v}}^{n+1, k}_{d}}{ \ave{\alpha_{g} \rho_{g}}^{n}_{a}} & 0
\end{bmatrix}_{j \pm \onehalf}
\end{equation}

Similarly, the momentum vector is given by \eqref{eqn:momenta_vector}.

\begin{equation}
\label{eqn:momenta_vector}
\vec{\dot{m}}^{n+1, k}_{j \pm \onehalf} = \begin{bmatrix}
\dot{m}_{l} \\
\dot{m}_{g} \\
\dot{m}_{e}
\end{bmatrix}^{n+1, k}_{j \pm \onehalf}
\end{equation}

The corresponding continuity equations for a given nonlinear boundary volume in residual formulation are given by \eqref{eqn:nbcNcgMassEquation} -- \eqref{eqn:nbcVapMassEquation}.

\begin{IEEEeqnarray}{rCl}
\label{eqn:nbcNcgMassEquation}
F^{k}_{c, n} & = & V_c\left[ (\alpha_g \rho_{n})^{n+1, k} -(\alpha_g \rho_{n})^{n}\right] +\dt{} \sum^{N_{f}}_{i\,=\,1}\left( \don{\alpha^{n}_g \rho^{n}_{n}}^{n+1,k}_{d} u^{n+1, k}_{g}  \cdot \vec{\bar{A}}\right)_{i} \nonumber \\
& + & \dt{} \sum^{N_{\text{NBC}}}_{p\,=\,1}\left( \Psi^{n+1, k}_{m,n} \right)_{p} \\
\label{eqn:nbcLiqMassEquation}
F^{k}_{m, l} & = & V_c \left(\alpha_l \rho_l \right)^{n+1,k} - V_c \left(\alpha_l \rho_l \right)^{n} + \dt{} \sum^{N_{f}}_{i\,=\,1} \left(\don{\alpha^n_l \rho^n_l}^{n+1,k}_{d} u^{n+1, k}_l \cdot \vec{\bar{A}}\right)_{i} \nonumber \\
&+& \dt{}\left[(1-\eta)\Gamma + S \right]^{n+1, k} +  \dt{} \sum^{N_{\text{NBC}}}_{p\,=\,1}\left( \Psi^{n+1, k}_{m,l} \right)_{p}  \\
\label{eqn:nbcGasEnergyEquation}
F^{k}_{e, g} & = & V_c \left[\left( \alpha_g \rho_g h_g \right)^{n+1, k} - \left( \alpha_g \rho_g h_g \right)^{n} - \alpha^{n}_{g} ( P^{\,n+1, k} - P^{\,n} ) \right] \nonumber \\
& - & \dt{} \left[q_{wg} + \Gamma h^{'}_v + q_{i,v} + q_{gl}\right]^{n+1, k} + \dt{} \sum^{N_{f}}_{i\,=\,1} \left(\don{\alpha^{n}_g \rho^{n}_g h_g^{n}}^{n+1,k}_{d} u^{n+1, k}_g  \cdot \vec{\bar{A}}\right)_{i} \nonumber \\
& + &  \dt{} \sum^{N_{\text{NBC}}}_{p\,=\,1}\left( \Psi^{n+1, k}_{e,g} \right)_{p} \\
\label{eqn:nbcLiqEnergyEquation}
F^{k}_{e, l} & = & V_c\left[\left( \alpha_l \rho_l h_l \right)^{n+1,k} - \left( \alpha_l \rho_l h_l \right)^{n} - \alpha^{n}_l (P^{\,n+1,k} - P^{\,n})\right] - \dt{} \left[q_{wl} -\Gamma h^{'}_l +  q_{i,l} - q_{gl}\right]^{n+1,k}    \nonumber \\
& +& \dt{} \sum^{N_{f}}_{i\,=\,1} \left( \don{\alpha^{n}_l \rho^{n}_l h^{n}_l}^{n+1,k}_{d} u^{n+1,k}_l \cdot \vec{\bar{A}} + \don{\alpha^{n}_e \rho^{n}_l h^{n}_l}^{n+1,k}_{d} u^{n+1,k}_e  \cdot \vec{\bar{A}}\right)_{i} \nonumber \\
& + &  \dt{} \sum^{N_{\text{NBC}}}_{p\,=\,1}\left( \Psi^{n+1, k}_{e,l} \right)_{p} \\
\label{eqn:nbcEntMassEquation}
F^{k}_{m, e} & = & V_c \left(\alpha_e \rho_l \right)^{n+1,k} - V_c \left(\alpha_e \rho_l \right)^{n} + \dt{} \sum^{N_{f}}_{i\,=\,1}\left( \don{\alpha^{n}_e \rho^{n}_l}^{n+1, k}_{d} u^{n+1,k}_e  \cdot \vec{\bar{A}}\right)_{i} \nonumber \\
&-& \dt{}\left[ S -\eta\Gamma \right]^{n+1,k} +  \dt{} \sum^{N_{\text{NBC}}}_{p\,=\,1}\left( \Psi^{n+1, k}_{m,e} \right)_{p}\\
\label{eqn:nbcVapMassEquation}
F^{k}_{c, v} & = & V_c \left[\left(\alpha_g \rho_v \right)^{n+1, k} - \left(\alpha_g \rho_v \right)^{n}\right] + \dt{} \sum^{N_{f}}_{i\,=\,1} \left( \don{\alpha^{n}_g \rho^{n}_v}^{n+1,k}_{d} u^{n+1, k}_{g}  \cdot \vec{\bar{A}}\right)_{i} - \dt{} \Gamma^{n+1, k} \nonumber \\
& + & \dt{} \sum^{N_{\text{NBC}}}_{p\,=\,1}\left( \Psi^{n+1, k}_{m,v} \right)_{p}
\end{IEEEeqnarray}

In the above equations, the number of flowpaths connecting the nonlinear boundary volume to other continuity volumes within the linear domain is given by $N_{f}$.
The summation index $i$ corresponds to the coordinate of the linear flowpath.
The number of flowpaths connecting the boundary volume to the nonlinear domain is given by $N_{\text{NBC}}$.
The summation index $p$ corresponds to the coordinates of the flowpath connecting the boundary volume to the nonlinear domain.

The linear system from \sect{sect:linCobraAlg}, \eqref{eqn:linSystem}, is modified by the introduction of the flow rates, $\vec{\Psi}$, as unknown parameters.
For the $N_{f}$ flowpaths connecting the boundary volume to the linear domain, there will be entries in the $\vec{K}_{c, j}$ matrix that correspond to the inter-continuity volume pressure coupling due to the momentum equations.
In addition there will now be $N_{\text{NBC}}$ identity matrices corresponding to the linear-nonlinear boundaries associated with the given continuity volume.
The identity matrices are produced by taking the derivatives of \eqref{eqn:nbcNcgMassEquation} -- \eqref{eqn:nbcVapMassEquation} with respect to the inter-domain flowrates, $\vec{\Psi}_{p}$.
The collection of these identity matrices is known as $\vec{P}$.
The resulting system is given by \eqref{eqn:nbcLinSystem}, where $N_{t} = 6 \left( 1 + N_{\text{NBC}}\right) + N_{f}$.

\begin{equation}
\label{eqn:nbcLinSystem}
\left[\right.\underbrace{\vec{Z}_{c, j}}_{6\, \text{x}\, N_{t}}\left.\right] \delta \vec{C}_{j} = \left[\right.\underbrace{\vec{J}_{c, j}}_{6\, \text{x}\, 6}|\underbrace{\vec{K}_{c, j}}_{6\, \text{x}\, N_{f}}|{\underbrace{\vec{P}_{c, j}}_{6\, \text{x}\, 6 N_{\text{NBC}}}}\left.\right]\delta \vec{C}_{j} = \vec{r}_{c,j}
\end{equation}

This system is then subjected to LU decomposition.
Up to this point, the discussion of the linear and nonlinear algorithms have avoided the use of full nonlinear system.

The following procedure will show the development of a single domain newton step.

\begin{equation}
\label{eqn:domainMatrix}
 \begin{bmatrix} 
\vec{J}_{c_1} & \vec{\Xi}_{c_1,m_1} & \vec{0} \\
\vec{J}_{m_1,c_1} & \vec{J}_{m_1} & \vec{J}_{m_1,c_2}  \\
\vec{0} & \vec{\Xi}_{c_2,m_1} & \vec{J}_{c_2} \\
 \end{bmatrix} \begin{bmatrix}
 \vec{\delta c}_{1} \\
 \vec{\delta m}_{1} \\
 \vec{\delta c}_{2} \\
\end{bmatrix}  = -\begin{bmatrix}
 \vec{F}_{c_1} \\
 \vec{F}_{m_1} \\
 \vec{F}_{c_2} \\
\end{bmatrix}
 \end{equation}
 
 \begin{equation}
\label{eqn:domainMatrix2}
 \begin{bmatrix} 
\vec{J}_{c_1} & \vec{\Xi}_{c_1,m_1} & \vec{0} \\
\frac{\partial \dot{\vec{m}}_{1}}{\partial P_{1} } & \vec{I} & \frac{\partial \dot{\vec{m}}_{1}}{\partial P_{2} }  \\
\vec{0} & \vec{\Xi}_{c_2,m_1} & \vec{J}_{c_2} \\
 \end{bmatrix} \begin{bmatrix}
 \vec{\delta c}_{1} \\
 \vec{\delta m}_{1} \\
 \vec{\delta c}_{2} \\
\end{bmatrix}  = \begin{bmatrix}
 - \vec{F}_{c_1} \\
 \delta \dot{\vec{m}}^{*} \\
 - \vec{F}_{c_2} \\
\end{bmatrix}
 \end{equation}
 
  
 \begin{equation}
\label{eqn:domainMatrix3}
 \begin{bmatrix} 
\vec{I} & \frac{\partial \dot{\vec{m}}_{1}}{\partial P_{1} } & \frac{\partial \dot{\vec{m}}_{1}}{\partial P_{2} }  \\
\vec{0} & \vec{J}_{c_1} - \vec{\Xi}_{c_1,m_1} \frac{\partial \dot{\vec{m}}_{1}}{\partial P_{1} } & - \vec{\Xi}_{c_1,m_1} \frac{\partial \dot{\vec{m}}_{1}}{\partial P_{2} }  \\
\vec{0} & -\vec{\Xi}_{c_2,m_1}\frac{\partial \dot{\vec{m}}_{1}}{\partial P_{1} } & \vec{J}_{c_2} - \vec{\Xi}_{c_2,m_1}\frac{\partial \dot{\vec{m}}_{1}}{\partial P_{2} } \\
 \end{bmatrix} \begin{bmatrix}
 \vec{\delta m}_{1} \\
 \vec{\delta c}_{1} \\
 \vec{\delta c}_{2} \\
\end{bmatrix}  = \begin{bmatrix}
 \delta \dot{\vec{m}}^{*} \\
 - ( \vec{F}_{c_1} + \vec{\Xi}_{c_1,m_1} \delta \dot{\vec{m}}^{*} ) \\
 - ( \vec{F}_{c_2} + \vec{\Xi}_{c_2,m_1} \delta \dot{\vec{m}}^{*} )\\
\end{bmatrix}
 \end{equation}

 \begin{equation}
\label{eqn:domainMatrix4}
 \begin{bmatrix} 
\vec{U}_{c_1} & - \vec{L}_{c_1}^{-1} \vec{\Xi}_{c_1,m_1} \frac{\partial \dot{\vec{m}}_{1}}{\partial P_{2} }  \\
-\vec{L}_{c_2}^{-1} \vec{\Xi}_{c_2,m_1}\frac{\partial \dot{\vec{m}}_{1}}{\partial P_{1} } & \vec{U}_{c_2} \\
 \end{bmatrix} \begin{bmatrix}
 \vec{\delta c}_{1} \\
 \vec{\delta c}_{2} \\
\end{bmatrix}  = \begin{bmatrix}
 - \vec{L}_{c_1}^{-1} ( \vec{F}_{c_1} + \vec{\Xi}_{c_1,m_1} \delta \dot{\vec{m}}^{*} ) \\
 - \vec{L}_{c_2}^{-1} ( \vec{F}_{c_2} + \vec{\Xi}_{c_2,m_1} \delta \dot{\vec{m}}^{*} )\\
\end{bmatrix}
 \end{equation}
 
  \begin{equation}
\label{eqn:domainMatrix5}
 \begin{bmatrix} 
1 & c_{1,2}  \\
c_{2,1} & 1 \\
 \end{bmatrix} \begin{bmatrix}
 \delta P_{1} \\
 \delta P_{2} \\
\end{bmatrix}  = \begin{bmatrix}
 f_1 \\
 f_2 \\
\end{bmatrix}
 \end{equation}
 
 The following is the domain decomposition version.
 
 \begin{equation}
\label{eqn:domainDecomp0}
 \begin{bmatrix} 
\vec{J}_{c_1} & \vec{\Xi}_{c_1,m_1} & \vec{0} \\
\vec{J}_{m_1,c_1} & \vec{J}_{m_1} & \vec{J}_{m_1,c_2}  \\
\vec{0} & \vec{\Xi}_{c_2,m_1} & \vec{J}_{c_2} \\
 \end{bmatrix} \begin{bmatrix}
 \vec{\delta c}_{1} \\
 \vec{\delta m}_{1} \\
 \vec{\delta c}_{2} \\
\end{bmatrix}  = -\begin{bmatrix}
 \vec{F}_{c_1} \\
 \vec{F}_{m_1} \\
 \vec{F}_{c_2} \\
\end{bmatrix}
 \end{equation}
 
 \begin{equation}
\label{eqn:domainDecomp1}
 \begin{bmatrix} 
\vec{J}_{c_1} & \vec{0} & - \vec{\Xi}_{m_1} & \vec{0} \\
\vec{0} & \vec{I} & \vec{\Xi}_{m_1} & 0 \\
\vec{J}_{m_1,c_1} & \vec{0} & \vec{J}_{m_1} & \vec{J}_{m_1,c_2}  \\
\vec{0} & \vec{0} & \vec{\Xi}_{m_1} & \vec{J}_{c_2} \\
 \end{bmatrix} \begin{bmatrix}
 \vec{\delta c}_{1} \\
 \vec{\delta \Psi}_{1} \\
 \vec{\delta m}_{1} \\
 \vec{\delta c}_{2} \\
\end{bmatrix}  = -\begin{bmatrix}
 \vec{F}_{c_1} \\
 \vec{0} \\
 \vec{F}_{m_1} \\
 \vec{F}_{c_2} \\
\end{bmatrix}
 \end{equation} 
 
 \begin{equation}
\label{eqn:domainDecomp2}
 \begin{bmatrix} 
\vec{J}_{c_1} & \vec{I} & \vec{0} & \vec{0} \\
\vec{0} & \vec{I} & \vec{\Xi}_{m_1} & 0 \\
\vec{J}_{m_1,c_1} & \vec{0} & \vec{J}_{m_1} & \vec{J}_{m_1,c_2}  \\
\vec{0} & \vec{0} & \vec{\Xi}_{m_1} & \vec{J}_{c_2} \\
 \end{bmatrix} \begin{bmatrix}
 \vec{\delta c}_{1} \\
 \vec{\delta \Psi}_{1} \\
 \vec{\delta m}_{1} \\
 \vec{\delta c}_{2} \\
\end{bmatrix}  = -\begin{bmatrix}
 \vec{F}_{c_1} \\
 \vec{0} \\
 \vec{F}_{m_1} \\
 \vec{F}_{c_2} \\
\end{bmatrix}
 \end{equation}
 
  
 \begin{equation}
\label{eqn:domainDecomp3}
 \begin{bmatrix} 
\vec{J}_{c_1} & \vec{I} & \vec{0} & \vec{0} \\
\vec{0} & \vec{I} & \vec{\Xi}_{m_1} & 0 \\
\frac{\partial \dot{\vec{m}}_{1}}{\partial P_{1} } & \vec{0} & \vec{I} & \frac{\partial \dot{\vec{m}}_{1}}{\partial P_{2} }  \\
\vec{0} & \vec{0} & \vec{\Xi}_{m_1} & \vec{J}_{c_2} \\
 \end{bmatrix} \begin{bmatrix}
 \vec{\delta c}_{1} \\
 \vec{\delta \Psi}_{1} \\
 \vec{\delta m}_{1} \\
 \vec{\delta c}_{2} \\
\end{bmatrix}  = \begin{bmatrix}
 - \vec{F}_{c_1} \\
 \vec{0} \\
 \delta \dot{\vec{m}}^{*} \\
 - \vec{F}_{c_2} \\
\end{bmatrix}
 \end{equation}

 \begin{equation}
\label{eqn:domainDecomp4}
 \begin{bmatrix} 
\vec{J}_{c_1} & \vec{I} & \vec{0} & \vec{0} \\
- \vec{\Xi}_{m_1}\frac{\partial \dot{\vec{m}}_{1}}{\partial P_{1} } & \vec{I} & \vec{0} & -\vec{\Xi}_{m_1}\frac{\partial \dot{\vec{m}}_{1}}{\partial P_{2} } \\
\frac{\partial \dot{\vec{m}}_{1}}{\partial P_{1} } & \vec{0} & \vec{I} & \frac{\partial \dot{\vec{m}}_{1}}{\partial P_{2} }  \\
\vec{0} & \vec{0} & \vec{\Xi}_{m_1} & \vec{J}_{c_2} \\
 \end{bmatrix} \begin{bmatrix}
 \vec{\delta c}_{1} \\
 \vec{\delta \Psi}_{1} \\
 \vec{\delta m}_{1} \\
 \vec{\delta c}_{2} \\
\end{bmatrix}  = \begin{bmatrix}
 - \vec{F}_{c_1} \\
 - \vec{\Xi}_{m_1} \delta \dot{\vec{m}}^{*} \\
 \delta \dot{\vec{m}}^{*} \\
 - \vec{F}_{c_2} \\
\end{bmatrix}
 \end{equation}
 
  \begin{equation}
\label{eqn:domainDecomp5}
 \begin{bmatrix} 
1 & c_{1,2}  \\
c_{2,1} & 1 \\
 \end{bmatrix} \begin{bmatrix}
 \delta P_{1} \\
 \delta P_{2} \\
\end{bmatrix}  = \begin{bmatrix}
 f_1 \\
 f_2 \\
\end{bmatrix}
 \end{equation}
 
\comment{
This is annoying as crap to describe.
I will give it a shot in words.
}

The procedures that were written to determine which continuity volumes were active and which were inactive were modified to separate the domain in two: a liner and a nonlinear domain.

When formulating the governing equations, the fluxes between the linear and nonlinear domains are treated as additional nonlinear variables.
When the linear domain is formulated, these flux terms are treated as variational parameters within the continuity volumes in the linear domain that lie on the boundary of the nonlinear domain.
Take for example a continuity volume with only two flowpaths connected to it.
One flow path is connected to another continuity volume within the linear domain.
The other flow path is connected to a continuity volume that resides within the nonlinear domain.
When the Jacobian for these continuity volumes are taken, derivatives with respect to the flux terms are included.
Since the flux terms are single terms in the equations, their derivatives are the identity matrix.
The regular Jacobian is a six by six matrix.
With the single linear connection, there is now an additional columns representing the change in the continuity equations with respect to the momenta the linear volume edge, \eqref{eqn:flux_matrix}.
This matrix is eliminated through the use of \eqref{eqn:momStar}.
The final system of equations for a given nonlinear boundary volume is a six by six + 1 * number of linear connections + 6 * number of nonlinear boundary connections.
In this example the final size of the matrix will be 6 x 13.
\begin{equation}
\vec{J}|\vec{C}|\vec{I} = -(\vec{F} + \vec{\Psi})
\end{equation}
The six for the number of nonlinear boundary connections is equivalent to the flux of masses and energies.
The residual for the nonlinear boundary volume does not include the flux into the nonlinear domain.
This is omitted at this step to enable simpler algebra later.
This system is then reduced in-place to the upper-triangular rectangular form. 

\begin{equation}
\vec{U}|\vec{L}^{-1}\vec{C}|\vec{L}^{-1} = -\vec{L}^{-1}(\vec{F} + \vec{\Psi})
\end{equation}

The last equation in this row is then normalized by its diagonal entry.

\begin{equation}
\vec{U}|\vec{L}^{-1}\vec{C}|\vec{L}^{-1} = -\vec{L}^{-1}(\vec{F} + \vec{\Psi})
\end{equation}

The Jacobian for each entry is then stored for later use.


After the solution in the nonlinear domain has been obtained, a loop over all continuity volumes in the linear domain is performed to obtain the new time values for the continuity volumes.
Each continuity volumes has 

\begin{equation}
\label{eqn:jacobianWithFluxTerms}
\vec{J}_{c,j} = 
\begin{bmatrix}
\frac{\partial F_{m,n}}{\partial (\alpha_g P_{n})} & \frac{\partial F_{m,n}}{\partial \alpha_g } & \frac{\partial F_{m,n}}{\partial (\alpha_g h_v)} & \frac{\partial F_{m,n}}{\partial ((1.0 - \alpha_g) h_l) } & \frac{\partial F_{m,n}}{\partial \alpha_e } & \frac{\partial F_{m,n}}{\partial P } \\
\frac{\partial F_{m,l}}{\partial (\alpha_g P_{n})} & \frac{\partial F_{m,l}}{\partial \alpha_g } & \frac{\partial F_{m,l}}{\partial (\alpha_g h_v)} & \frac{\partial F_{m,l}}{\partial ((1.0 - \alpha_g) h_l)} &\frac{\partial F_{m,l}}{\partial \alpha_e } & \frac{\partial F_{m,l}}{\partial P } \\
\frac{\partial F_{e,g}}{\partial (\alpha_g P_{n})} & \frac{\partial F_{e,g}}{\partial \alpha_g } & \frac{\partial F_{e,g}}{\partial (\alpha_g h_v)} & \frac{\partial F_{e,g}}{\partial ((1.0 - \alpha_g) h_l)} &\frac{\partial F_{e,g}}{\partial \alpha_e } & \frac{\partial F_{e,l}}{\partial P } \\
\frac{\partial F_{e,l}}{\partial (\alpha_g P_{n})} & \frac{\partial F_{e,l}}{\partial \alpha_g } & \frac{\partial F_{e,l}}{\partial (\alpha_g h_v)} & \frac{\partial F_{e,l}}{\partial ((1.0 - \alpha_g) h_l)} &\frac{\partial F_{e,l}}{\partial \alpha_e } & \frac{\partial F_{e,g}}{\partial P } \\
\frac{\partial F_{m,e}}{\partial (\alpha_g P_{n})} & \frac{\partial F_{m,e}}{\partial \alpha_g } & \frac{\partial F_{m,e}}{\partial (\alpha_g h_v)} & \frac{\partial F_{m,e}}{\partial ((1.0 - \alpha_g) h_l)} &\frac{\partial F_{m,e}}{\partial \alpha_e } & \frac{\partial F_{m,e}}{\partial P } \\
\frac{\partial F_{m,v}}{\partial (\alpha_g P_{n})} & \frac{\partial F_{m,v}}{\partial \alpha_g } & \frac{\partial F_{m,v}}{\partial (\alpha_g h_v)} & \frac{\partial F_{m,v}}{\partial ((1.0 - \alpha_g) h_l)} & \frac{\partial F_{m,v}}{\partial \alpha_e } & \frac{\partial F_{m,v}}{\partial P }
\end{bmatrix}
\end{equation}
 
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\section{Implementation in \cobra{}}
\label{sec:dd_algo}

The domain decomposition method outlined in \sect{sec:domDecompMath} was integrated into the \cobra{} software.
In this section, several architectural changes necessary to implement the domain decomposition are outlined.
First, the modification of how the solvers are structured is discussed.
Then, the implementation of an object-oriented domain system for proper domain identification is detailed.
The algorithmic implementation of the domain decomposition method will be shown in detail.
Lastly, the dual domain input file is described.

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\subsection{Pressure Matrix Data Structures}
\label{subsect:domDecompSolverStructs}

As seen in \sect{sect:linCobraAlg}, the linear system that ends up being solved to obtain the Newton update vector is the pressure matrix.
\cobra{} provides the user with the ability to chose from three different linear algebra methods for solver the pressure matrix.
The method that the user selects via the \cobra{} input file, ``\classname{deck.inp}" determines the data storage structure of the pressure matrix.
Each of the three methods utilizes a different matrix storage format.
Given that the original software was written in a mixture FORTRAN 77 and Fortran 90, and as such was based upon procedural programming practices, the memory structure for each of the three possible pressure matrices were predefined in different modules.
However, this paradigm precluded the existence of two pressure matrices, one for the linear domain and one for the nonlinear domain.
The way in which the solver was stored and accessed was modified to enable multiple solvers and to reduce the logical complexity of accessing the proper matrix.

\cobra{} provides the user with three options for the linear algebra method to be used for solving for the pressure update.
These are the Gauss elimination, the SuperLU solver \cite{Li1999}, and the Pardiso solver \cite{Schenk2006, Schenk2007}.
The SuperLU and the Pardiso solvers utilize sparse matrix storage and the Gauss elimination routine utilizes a full matrix.
The sparsity of the matrices typically encountered are such that use of the direct solver is discouraged.

\begin{figure}[ht!]
\singlespace\centering
\input{images/matrixClassDiagram}
\caption{Matrix Class Diagram}
\label{fig:matrixClassDiagram}
\end{figure}

This architecture was deemed to be inappropriate for the work being done.
The object-oriented features in Fortran 2003/2008 standards provided an alternative method of handling the pressure matrix.
The matrix storage structure was first replaced with an abstract class, \classname{matrix}.
The \classname{matrix} class contains the number of right hand sides anticipated as well as the total number of pressure updates, $N$.
Additionally, this class would provide interfaces for the following procedures:

\begin{itemize}
\item{put : a procedure that sets $\vec{A}_{i,j}$ to a given value.}
\item{get : a procedure that returns $\vec{A}_{i,j}$.}
\item{scale : a procedure for scaling $\vec{A}_{i, :}$ by a given value.}
\item{reset : a procedure for setting $\vec{A} = \vec{0}$.}
\item{invert : a procedure that returns $\vec{x}$ from $\vec{A}\vec{x} = \vec{b}$.}
\end{itemize}

Given that the SuperLU and the Pardiso solvers utilize sparse matrices and the Gauss elimination routine uses a full matrix, there are two further abstract classes that inherit from \classname{matrix}; they are \classname{fullMatrix} and \classname{sparseMatrix}.
The \classname{fullMatrix} class contains an array representing $\vec{A}$.
The \classname{sparseMatrix} class contains the information required to construct a sparse matrix; however, the exact storage format is not specified in \classname{sparseMatrix}.
Both \classname{fullMatrix} and \classname{sparseMatrix} contain procedural implementations of the interfaces defined in \classname{matrix}.
There are three concrete classes that correspond to the three supported solvers: \classname{dsolveMatrix}, \classname{superluMatrix}, and \classname{pardisoMatrix}; all three implement their own linear system solving routines under the invert interface.
\classname{dsolveMatrix} is a concrete class inheriting from \classname{fullMatrix} that includes pivoting information.
\classname{superluMatrix} and \classname{pardisoMatrix} are concrete classes inheriting from \classname{sparseMatrix} that implement the matrix storage schemes for their respective solvers.
\fig{fig:matrixClassDiagram} shows the class diagram for the \classname{matrix} ecosystem.

\begin{figure}[ht!]
\singlespace\centering
\input{images/solverClassDiagram}
\caption{Solver Class Diagram}
\label{fig:solverClassDiagram}
\end{figure}

Once the matrix ecosystem was developed, an abstract solver class was designed.
The \classname{solver} class contains the size of the system, $N_{a}$; a pointer to a \classname{matrix} object, $\vec{A}$; and the right hand side of the linear system, \classname{reS}.
\classname{solver} specifies the interface for an initialization routine, init.
In addition, \classname{solver} specifies the following procedures for manipulating the linear system:

\begin{itemize}
\item{ insert : a procedure for inserting a continuity volume's pressure equation into $\vec{A}_{i, :}$.}
\item{ solve : an interface to call the solver associated with the matrix.}
\item{ scale : a procedure for scaling $\vec{A}_{i, :}$ and $\vec{res}_{i}$.}
\item{ reset : a procedure for setting $\vec{A} = \vec{0}$ and $\vec{res} = \vec{0}$.}
\end{itemize}

There are three concrete classes that inherit from the abstract solver class: \classname{dsolveSolver}, \classname{superluSolver}, and \classname{pardisoSolver}.
Each of these concrete classes specifies an initialization routine that takes an adjacency list data structure, instantiates the \classname{matrix} pointer to the appropriate concrete subtype, and sets the appropriate matrix parameters.
By abstracting the matrices and solvers in this way, a consistent interface is provided to the rest of the software.
\fig{fig:solverClassDiagram} shows the class diagram for the \classname{solver} ecosystem.

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\subsection{Volume Data Structures}
\label{subsect:domDecompVolumeStructs}

A difficulty that had to be overcome during this work was indexing.
The in memory storage of many indexing variables was based upon a universal ordinal system for continuity volumes.
This ordinal system corresponded to the ordinals for a single pressure matrix.
It was determined that programmatic complexity of trying to maintain a single ordinal system for the dual domains was greater than that of redesigning the memory architecture.
As part of the redesign, the software was partially transitioned to an object based mesh.

A continuity volume was chosen as the basic unit of the domain.
Given the dual domain, there were two types of continuity volumes that needed to be distinguished.
There are continuity volumes that inhabit a single domain, and there are those which are in the linear domain but have a flowpath connecting to the nonlinear domain.
Those volumes in the nonlinear volume that are connected to the linear domain via a flowpath do not need to have any additional information storage, so they are not considered to be exceptional volumes.
The volume class diagram for \cobra{} is outlined in \fig{fig:volumeClassDiagram}.

\begin{figure}[ht!]
\singlespace\centering
\input{images/volumeClassDiagram}
\caption{Volume Class Diagram}
\label{fig:volumeClassDiagram}
\end{figure}

The basic continuity volume class is the \classname{baseVolume} class.
This class contains basic connectivity information for the continuity volume.
Each \classname{baseVolume} object has a pointer to the solver object associated with its domain.
A \classname{baseVolume} that corresponds to a continuity volume in the linear domain has a \classname{solver} pointer to the solver for linear pressure matrix.
The nonlinear domain's continuity volumes have a \classname{solver} pointer to the solver for the nonlinear pressure matrix.
This allows each continuity volume to be able to access the correct pressure matrix without having to reference a logical map or perform a calculation.
In addition to the solver, the volume's ordinal is stored.
This variable provides indexing information for the volume's pressure matrix.

Additionally, information regarding the connectivity of the volume to other volumes is stored in several variables: \classname{num\_cons}, \classname{cons}, \classname{con\_type}, \classname{con\_ord}, \classname{gap\_ord}, \classname{con\_coords}, \classname{fp\_coords}, and \classname{con\_sig}.
These variables represent the information necessary to properly references those flowpaths to which the continuity volume is connected as well as the continuity volumes on the other end of the flowpaths.
This data structure has the drawback of storing redudent information as that the continuity volumes connected via a given flowpath contain all the information of that flowpath in two separate memory locations.
This issue is known, and its resolution is part of ongoing development work of \cobra{}.

The volume also contains the Jacobian matrix and the right hand sides from \sect{sect:linCobraAlg}.
The local Jacobian matrix $\vec{J}_{c, j}$ is stored as \classname{jac}.
The right hand side of the continuity volume's linear system, $\vec{F}_{c, j}$, is stored as \classname{b}.
The variable \classname{b\_ords} provides a mapping between the local continuity volume's residual and flux coefficients to the global pressure matrix's ordinals.

Those linear continuity volumes that are connected to the nonlinear domain via a flowpath have their own \classname{nbcVolume} class.
This class, as shown in \fig{fig:volumeClassDiagram}, contains the additional information required to perform the domain decomposition.
First, a second \classname{solver} pointer is present, \classname{nln\_solver}.
This allows for proper indexing into nonlinear pressure matrix when needed.
The \classname{nbcVolume} also contains a separate collection of variables describing those flowpaths that connect it to the nonlinear domain: \classname{nbc\_cons}, \classname{nbc\_con\_ord}, \classname{nbc\_con\_map}, \classname{nbc\_ords}, \classname{nbc\_coords}, \classname{coords}, and \classname{nln\_ord\_by\_local\_nbc\_ord}.
In addition to the information regarding the flowpaths, the \classname{nbcVolume} class also contains the pressure coefficients, \classname{coef\_mat}; the flux associated with the boundary, \classname{flux}; the derivative of the flux with respect to the pressure on either side of the flowpath, \classname{dflux\_dp}; the matrix $\vec{\Xi}$ in compressed storage, \classname{donored\_values}; and the right hand side of the linear domain's pressure solution, \classname{dp}.

Each continuity volume is represented by one of the above described volumes.
This polymorphic approach allows for domain agnostic subroutines and functions within the software.


%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\subsection{Domain Decomposition Algorithm}
\label{subsect:domDecompAlgorithm}

First, the input file is parsed to determine which channels are in the nonlinear domain.
The entire domain is traversed to determine which volumes are in the nonlinear domain and which volumes are in the linear domain.

A single timestep is now broken into two parts, the linear part and the nonlinear part.
At the beginning of a timestep, the entire domain is traversed to assemble the pressure matrices for both the linear and the nonlinear domains.
However, there are differences when a \classname{nbcVolume} is encountered.
First, the equations used in these volumes are those outlined in 

Each continuity volume's linearized system of equations, \eqref{eqn:linSystem}, is subjected to partial LU decomposition without pivoting.
The lower triangular matrix has a unit diagonal.
The sixth equation in the upper-triangular system is then scaled by its diagonal.
This upper-triangular rectangular system for each continuity volume is then stored for later back-substitution.
Since the pressure update corresponds to the last row in the system of equations, this allows for the isolation of the pressure updates.
The last row of each continuity volume's \eqref{eqn:linSystem} is then formed into a global pressure matrix, $\vec{A}_{N,N}$, and its associated right hand side, $\vec{r}$.

The two loops, one over the momentum volumes and one over the continuity volumes, form a single group of operations that act upon a given domain.
This grouping will be known hereafter as assembling the pressure matrix for a given domain.
\alg{alg:xschem} shows the two loops and their associated actions.


Each continuity volume within the linear domain that connects to the nonlinear domain is treated slightly differently.
The flux terms from the equations are not included in the residual.
The derivatives of those flux terms are also not included in the linear system.
This changes the size of $\vec{C}_{j}$ by removing one of the entries.
Additionally, the derivatives of the flux terms with respect to themselves, the identify matrix $\vec{I}$, is added to the linear system.
If a linear continuity volume is attached through more than one surface to the nonlinear domain, then there will be multiple identity matrices in the continuity volume's linear system.
The resulting system will be subjected to the same LU decomposition as outlined for a regular volume.
The last equation with the additional right hand sides will be assembled into the linear domains pressure matrix.
The linear system for the linear domain is inverted by the chosen solver.
The additional coefficients represent the coefficients for the boundary flux between the linear and the nonlinear domain.
After the inversion of the pressure matrix, then coefficients for the nonlinear boundary volumes are collected into the nonlinear boundary volumes for ease of manipulation later.
This is shown in \alg{alg:domDecompGetCoef}.

\begin{algo}[ht!]
\setlength{\baselineskip}{0.625\baselineskip}
\begin{algorithmic}[1]
\Set x = 2
\end{algorithmic}
\caption{Obtain Nonlinear Boundary Volume Coefficients.}
\label{alg:domDecompGetCoef}
\end{algo}

Now that the coefficients have been collected and the linear domain has been inverted, the additional entries in the nonlinear pressure matrix that represent the boundary pressures are populated.
This population is accomplished by looping over all the nonlinear boundary volumes.
For each nonlinear boundary volume  has a pressure equation associated with it.
Due to the inversion of the linear domain's pressure matrix, the pressure of each nonlinear boundary volumes now has a dependence upon all other nonlinear boundary volumes and the nonlinear volumes to which they attach.
This creates a second loop inside of the outer loop that loops over all the nonlinear boundary volumes again.
Within this loop there is a third loop that goes over all of the interfaces that that volume has with the nonlinear domain.
This is a system of three nested loops.
The inner nonlinear boundary volume loop calculates the flux derivatives with respect to pressures with comparison to 
After this, the linear pressure matrix with the additional right hand sides is inverted.)
Once the linear pressure matrix is inverted, the coefficients for the nonlinear boundary volumes are collected via \alg{alg:domDecompGetCoef}.

\begin{algo}[ht!]
\setlength{\baselineskip}{0.625\baselineskip}
\begin{algorithmic}[1]
\Require $\vec{x}^{0}$ and $t^{0}$
\Set $n = 0$
\Loop \; Transient Loop
    \Set $t^{n+1} : = t^{n} + \dt{}$
	\Algorithm Assemble Nonlinear and Linear Pressure Matrices	 \Comment{\alg{alg:xschem}}
	\If{ \textbf{LinearSolver} }
		\Solve $\vec{A}_{l} \vec{\delta P}_{l} = \vec{res}_{l}$	
	\EndIf
	\If{ \textbf{NonlinearSolver} }
	    \Set $k = 0$
		\Algorithm Get Nonlinear Coefficients \Comment{\alg{alg:domDecompGetCoef}}
		\Algorithm Set Nonlinear Boundary Values \Comment{\alg{alg:domDecompSetMat}}
		\Solve $\vec{A}^{k}_{n} \vec{\delta P}_{n}^{k} = \vec{res}_{n}^{k}$	
		\Algorithm Update Nonlinear Variables \Comment{\alg{alg:updateVariables}} 
	    \Loop \; Newton Loop
			\Algorithm Assemble Nonlinear Pressure Matrix \Comment{\alg{alg:xschem}}
			\Algorithm Convergence Determination \Comment{\alg{alg:nlnConvergence}}
			\If{ \textbf{end} Newton loop}
				\State Undo partial Newton Step
				\State \textbf{break} Newton Loop 
			\EndIf		
			\Set $k \pluseq 1$
			\Algorithm Set Nonlinear Boundary Values \Comment{\alg{alg:domDecompSetMat}}
			\Solve $\vec{A}^{k} \vec{\delta P}^{k} = \vec{res}^{k}$
			\Algorithm Update Nonlinear Variables \Comment{\alg{alg:updateVariables}}
		\EndLoop
	\EndIf
	\If{ \textbf{LinearSolver} }
		\Algorithm Update Linear Variables \Comment{\alg{alg:updateVariables}}
	\EndIf
	\Set $n \pluseq 1$
\EndLoop
\end{algorithmic}
\caption{Dual domain \cobra{} algorithm.}
\label{alg:domDecompAlgorithm}
\end{algo}

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\subsection{Dual Domain Input File}
\label{subsect:domDecompInputFile}

In order to activate the spatially selective nonlinear solver, the nonlinear solver input file needs to have additional information.
The ID of the channels that are going to be subjected to additional Newtons steps needs to be specified.
The basic nonlinear convergence is still input as described in \sect{subsect:nlnCobraInputFile}.
The nonlinear convergence tolerances and iteration limit only apply to the nonlinear domain.
However, there is now additional information appended to the basic nonlinear input.
The presence of the character string ``'begin-nln-channels'" after the nonlinear input signals that there will be two domains.
After that string, the ID of the channels are listed, one per line, in no particular order.
Once all channels to be in the nonlinear domain have been listed, the character string ``'end-nln-channels'" needs to be on a separate line.
The following is an example of the dual domain input segment of the ``\classname{nwt.cob}" input file.

{
\singlespace
\begin{verbatim}
'begin-nln-channels'
<chanID_1>
<chanID_2>
<chanID_3>
...
<chanID_N>
'end-nln-channels'
\end{verbatim}
}

In the above example, <chanID\_N> is the channel ID that will be included in the nonlinear domain.
The input processing routine has extensive error checking and user feedback for proper formatting of this input.
Note that there is no requirement that the channels specified to be in the nonlinear domain form a contiguous domain.


