\chapter{Domain Decomposition}
\label{chap:domain_decomposition}
As discussed in \ref{sect:code_coupling}, domain decomposition in thermal-hydraulic, safety-analysis software is an established method to allow for different physics to be represented in different domains.
The governing partial differential equations described in \sect{subsect:governing_equations} contain nonlinearities that are distributed in both space and time.
In the absence of nonlinear physics a single Newton step is adequate to solve the governing set of discrete algebraic equations.
However, if the number of Newton steps is limited to one for a given spatial mesh when nonlinearities are present, then the only way to resolve those nonlinearities is to refine the temporal discretization.
If the number of Newton steps is not limited to one, then the nonlinearities may be resolved for a fixed temporal discretization.
When the nonlinearities are isolated to a given nonlinear portion of the domain, the additional Newton steps do not improve the solution in the linear portion of the domain.
The ability to resolve the nonlinear physics only where they occur could potentially provide a way to reduce the computational cost associated with resolving the nonlinear error for a given timestep.
This research extends the domain coupling framework to allow for different domains to be consistently coupled while subject to different mathematical treatments.
The following section contains three sections that describe the mathematical formulation of the domain decomposition, a description of its implementation, and several problems that were used to verify that the algorithm had been implemented properly.

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\section{Mathematical Formulation}
\label{sec:domDecompMath}

With the selective nonlinear refinement algorithm, the domain is split into two segments, a linear domain and a nonlinear domain.
There is no requirement that these two domains be contiguous.
Each continuity volume and momentum flow path is characterized as either existing in the linear domain or the nonlinear domain.
Each momentum flow path is associated with a single domain; the momentum equations are not modified, regardless of the domain in which they exists.
The coupling between the two domains occurs at the interfaces between the linear and the nonlinear domains.
Those continuity volumes which are in the linear domain, but have flow paths connecting them to the nonlinear domain, are considered to be nonlinear boundary volumes.
All other continuity volumes have associated with them the nonlinear continuity equations, \eqref{eqn:nlnNcgMassEquation} -- \eqref{eqn:nlnVapMassEquation}.
The nonlinear boundary volumes on the linear side of the domains' interface have a modified set of conservation equations which will now be discussed.

The starting place for the formulation of the nonlinear boundary volumes' continuity equations will be \eqref{eqn:nlnNcgMassEquation} -- \eqref{eqn:nlnVapMassEquation}.
In these normal nonlinear continuity equations the advection terms are formulated in terms new-time velocities and donored quantities evaluated using the new-time velocities.
However, in a nonlinear boundary volume, the $N_{\text{NBC}}$ flow paths that connects the linear continuity volume to the nonlinear continuity volume is formulated in terms of phasic mass and energy flow rates, \eqref{eqn:massAndEnergyFluxes}.

\begin{equation}
\label{eqn:massAndEnergyFluxes}
\vec{\Psi}^{n+1, k}_{j \pm \onehalf} = \begin{bmatrix}
\Psi_{c, n} \\
\Psi_{c, l} \\
\Psi_{e, g} \\
\Psi_{e, l} \\
\Psi_{c, e} \\
\Psi_{c, v} \\
\end{bmatrix}^{n+1, k}_{j \pm \onehalf}
\end{equation}

This formulation introduces six new unknowns per domain connection the flow rates.
The definition of the six unknown flow rates are shown in \eqref{eqn:nbcFluxDefinition}.

\begin{equation}
\label{eqn:nbcFluxDefinition}
\vec{\Psi}^{n+1, k}_{j \pm \onehalf} = \begin{bmatrix}
\frac{\don{\alpha^{n}_{g} \rho^{n}_{n}}^{n+1,k}_{d}}{\ave{\alpha_{g} \rho_{g}}^{n}_{a}}\dot{m}^{n+1,k}_{g} \\
%
\frac{\don{\alpha^{n}_{l}\rho^{n}_{l}}^{n+1,k}_{d}}{\ave{\alpha_{l} \rho_{l}}^{n}_{a}}\dot{m}^{n+1,k}_{l}\\
%
\frac{\don{\alpha^{n}_{g} \rho^{n}_{g} h^{n}_{g}}^{n+1,k}_{d}}{\ave{\alpha_{g} \rho_{g}}^{n}_{a}}\dot{m}^{n+1, k}_{g}\\
%
\frac{\don{\alpha^{n}_{l}\rho^{n}_{l} h^{n}_{l}}^{n+1,k}_{d}}{\ave{\alpha_{l} \rho_{l}}^{n}_{a}}\dot{m}^{n+1, k}_{l} +\frac{\don{\alpha^{n}_{e} \rho^{n}_{l} h^{n}_{l}}^{n+1, k}_{d}}{\ave{\alpha_{e} \rho_{l}}^{n}_{a}}\dot{m}^{n+1, k}_{e} \\
%
\frac{ \don{\alpha^{n}_{e} \rho^{n}_{l}}^{n+1, k}_{d}}{ \ave{\alpha_{e} \rho_{l}}^{n}_{a}} \dot{m}^{n+1, k}_{e} \\
%
\frac{ \don{\alpha^{n}_{g} \rho^{n}_{v}}^{n+1, k}_{d}}{ \ave{\alpha_{g} \rho_{g}}^{n}_{a}} \dot{m}^{n+1, k}_{g}
\end{bmatrix}_{j \pm \onehalf}
\end{equation}

Using \eqref{eqn:momentumToFlowRates} and \eqref{eqn:momentumVector}, the flow rate vector, $\vec{\Psi}$, can be expressed in matrix form as \eqref{eqn:nbcFluxMatrixStyle}.

\begin{equation}
\label{eqn:nbcFluxMatrixStyle}
\vec{\Psi}^{n+1, k}_{j \pm \onehalf} = \vec{\Xi}^{n+1, k}_{j \pm \onehalf} \cdot \vec{\dot{m}}^{n+1, k}_{j \pm \onehalf}
\end{equation}

The corresponding continuity equations for a given nonlinear boundary volume in residual formulation are given by \eqref{eqn:nbcNcgMassEquation} -- \eqref{eqn:nbcVapMassEquation}.

\begin{IEEEeqnarray}{rCl}
\label{eqn:nbcNcgMassEquation}
F^{k}_{c, n} & = & V_c\left[ (\alpha_g \rho_{n})^{n+1, k} -(\alpha_g \rho_{n})^{n}\right] +\dt{} \sum^{N_{f}}_{i\,=\,1}\left( \don{\alpha^{n}_g \rho^{n}_{n}}^{n+1,k}_{d} u^{n+1, k}_{g}  \cdot \vec{\bar{A}}\right)_{i} \nonumber \\
& + & \dt{} \sum^{N_{\text{NBC}}}_{p\,=\,1}\left( \Psi^{n+1, k}_{m,n} \right)_{p} \\
\label{eqn:nbcLiqMassEquation}
F^{k}_{m, l} & = & V_c \left(\alpha_l \rho_l \right)^{n+1,k} - V_c \left(\alpha_l \rho_l \right)^{n} + \dt{} \sum^{N_{f}}_{i\,=\,1} \left(\don{\alpha^n_l \rho^n_l}^{n+1,k}_{d} u^{n+1, k}_l \cdot \vec{\bar{A}}\right)_{i} \nonumber \\
&+& \dt{}\left[(1-\eta)\Gamma + S \right]^{n+1, k} +  \dt{} \sum^{N_{\text{NBC}}}_{p\,=\,1}\left( \Psi^{n+1, k}_{m,l} \right)_{p}  \\
\label{eqn:nbcGasEnergyEquation}
F^{k}_{e, g} & = & V_c \left[\left( \alpha_g \rho_g h_g \right)^{n+1, k} - \left( \alpha_g \rho_g h_g \right)^{n} - \alpha^{n}_{g} ( P^{\,n+1, k} - P^{\,n} ) \right] \nonumber \\
& - & \dt{} \left[q_{wg} + \Gamma h^{'}_v + q_{i,v} + q_{gl}\right]^{n+1, k} + \dt{} \sum^{N_{f}}_{i\,=\,1} \left(\don{\alpha^{n}_g \rho^{n}_g h_g^{n}}^{n+1,k}_{d} u^{n+1, k}_g  \cdot \vec{\bar{A}}\right)_{i} \nonumber \\
& + &  \dt{} \sum^{N_{\text{NBC}}}_{p\,=\,1}\left( \Psi^{n+1, k}_{e,g} \right)_{p} \\
\label{eqn:nbcLiqEnergyEquation}
F^{k}_{e, l} & = & V_c\left[\left( \alpha_l \rho_l h_l \right)^{n+1,k} - \left( \alpha_l \rho_l h_l \right)^{n} - \alpha^{n}_l (P^{\,n+1,k} - P^{\,n})\right] - \dt{} \left[q_{wl} -\Gamma h^{'}_l +  q_{i,l} - q_{gl}\right]^{n+1,k}    \nonumber \\
& +& \dt{} \sum^{N_{f}}_{i\,=\,1} \left( \don{\alpha^{n}_l \rho^{n}_l h^{n}_l}^{n+1,k}_{d} u^{n+1,k}_l \cdot \vec{\bar{A}} + \don{\alpha^{n}_e \rho^{n}_l h^{n}_l}^{n+1,k}_{d} u^{n+1,k}_e  \cdot \vec{\bar{A}}\right)_{i} \nonumber \\
& + &  \dt{} \sum^{N_{\text{NBC}}}_{p\,=\,1}\left( \Psi^{n+1, k}_{e,l} \right)_{p} \\
\label{eqn:nbcEntMassEquation}
F^{k}_{m, e} & = & V_c \left(\alpha_e \rho_l \right)^{n+1,k} - V_c \left(\alpha_e \rho_l \right)^{n} + \dt{} \sum^{N_{f}}_{i\,=\,1}\left( \don{\alpha^{n}_e \rho^{n}_l}^{n+1, k}_{d} u^{n+1,k}_e  \cdot \vec{\bar{A}}\right)_{i} \nonumber \\
&-& \dt{}\left[ S -\eta\Gamma \right]^{n+1,k} +  \dt{} \sum^{N_{\text{NBC}}}_{p\,=\,1}\left( \Psi^{n+1, k}_{m,e} \right)_{p}\\
\label{eqn:nbcVapMassEquation}
F^{k}_{c, v} & = & V_c \left[\left(\alpha_g \rho_v \right)^{n+1, k} - \left(\alpha_g \rho_v \right)^{n}\right] + \dt{} \sum^{N_{f}}_{i\,=\,1} \left( \don{\alpha^{n}_g \rho^{n}_v}^{n+1,k}_{d} u^{n+1, k}_{g}  \cdot \vec{\bar{A}}\right)_{i} - \dt{} \Gamma^{n+1, k} \nonumber \\
& + & \dt{} \sum^{N_{\text{NBC}}}_{p\,=\,1}\left( \Psi^{n+1, k}_{m,v} \right)_{p}
\end{IEEEeqnarray}

In the above equations, the number of flow paths connecting the nonlinear boundary volume to other continuity volumes within the linear domain is given by $N_{f}$.
The summation index $i$ corresponds to the coordinate of the linear flow path.
The number of flow paths connecting the nonlinear boundary continuity volume to the nonlinear domain is given by $N_{\text{NBC}}$.
The summation index $p$ corresponds to the coordinates of the flow path connecting the nonlinear boundary continuity volume to the nonlinear domain.

By treating the boundary flow rates as independent parameters, the linearized system given in \eqref{eqn:nlnContinuitySystem} is modified to be \eqref{eqn:nbcContinuitySystem}.

\begin{IEEEeqnarray}{rcl}
\label{eqn:nbcContinuitySystem}
 - \vec{F}^{k}_{c} & = & \frac{\partial \vec{F}^{k}_{c}}{\partial (\alpha_{g} P_{n} )} \delta (\alpha_{g} P_{n})^{k} + \frac{\partial \vec{F}^{k}_{c}}{\partial \alpha_{g}} \delta \alpha^{k}_{g} + \frac{\partial \vec{F}^{k}_{c}}{\partial (\alpha_{g} h_{v} )} \delta (\alpha_{g} h_{v})^{k} + \frac{\partial \vec{F}^{k}_{c}}{\partial ((1 - \alpha_{g}) h_{l} )} \delta ((1 - \alpha_{g}) h_{l})^{k} \nonumber \\
& + & \frac{\partial \vec{F}^{k}_{c}}{\partial \alpha_{e}} \delta \alpha_{e}^{k} + \frac{\partial \vec{F}^{k}_{c}}{\partial P } \delta P^{k} + \sum^{N_{f}}_{i\,=\,1} \frac{\partial \vec{F}^{k}_{c}}{\partial \momVec{}_{i} } \delta \momVec{}_{i}^{k} + \sum^{N_{\text{NBC}}}_{p\,=\,1} \frac{\partial \vec{F}^{k}_{c}}{\partial \vec{\Psi}_{p} } \delta \vec{\Psi}_{p}^{k} 
\end{IEEEeqnarray}

Since the continuity equations are linear in the boundary flow rates, the matrix of derivatives of the NBC volumes' continuity equations with respect to the boundary flow rates, $ \frac{\partial \vec{F}^{k}_{c}}{\partial \vec{\Psi}_{p} } $, is the identity matrix times the timestep size, $\dt{} \vec{I}$.
For algorithmic convenience, the unknown flow rates in the continuity equations' residuals are kept as unknown parameters when solving the local linear system.
However, the residual used for convergence does include this term.
Utilizing the above two items, \eqref{eqn:momentumToFlowRates}, and \eqref{eqn:momentumUpdate}, the linear system for the NBC volume, \eqref{eqn:nbcContinuitySystem}, can be expressed as \eqref{eqn:nbcLinearSystem} in a manner analogous to that outlined in \sect{sect:nlnCobraSolver}.

\begin{IEEEeqnarray}{rcl}
\label{eqn:nbcLinearSystem}
\frac{\partial \vec{F}^{k}_{c}}{\partial (\alpha_{g} P_{n} )} \delta (\alpha_{g} P_{n})^{k} + \frac{\partial \vec{F}^{k}_{c}}{\partial \alpha_{g}} \delta \alpha^{k}_{g} + \frac{\partial \vec{F}^{k}_{c}}{\partial (\alpha_{g} h_{v} )} \delta (\alpha_{g} h_{v})^{k} + \frac{\partial \vec{F}^{k}_{c}}{\partial ((1 - \alpha_{g}) h_{l} )} \delta ((1 - \alpha_{g}) h_{l})^{k} & + & \nonumber \\
\frac{\partial \vec{F}^{k}_{c}}{\partial \alpha_{e}} \delta \alpha_{e}^{k} + \left( \frac{\partial \vec{F}^{k}_{c}}{\partial P } + \sum^{N_{f}}_{i\,=\,1} \vec{\Xi}^{k}_{i}\frac{\partial \momVec{}^{k}_{i}}{\partial P}\right) \delta P^{k} + \sum^{N_{f}}_{i\,=\,1} \vec{\Xi}^{k}_{i} \frac{\partial \momVec{}^{k}}{\partial P_{i}} \delta P_{i}^{k} + \dt{} \sum^{N_{\text{NBC}}}_{p\,=\,1} \delta \vec{\Psi}^{k}_{p} & = &\nonumber \\
- \left( \vec{F}^{k}_{c} + \sum^{N_{f}}_{i\,=\,1} \vec{\Xi}^{k}_{i} \delta \momVec{}_{i}^{*} - \dt{} \sum^{N_{\text{NBC}}}_{p\,=\,1} \vec{\Psi}^{k}_{p} \right) - \dt{} \sum^{N_{\text{NBC}}}_{p\,=\,1} \vec{\Psi}^{k}_{p} & &
\end{IEEEeqnarray}

As outlined in \sect{sect:nlnCobraSolver}, the advection terms in the residuals on the right hand side of \eqref{eqn:nbcLinearSystem} are evaluated using $\momVec{}^{n+1, k + \onehalf}$.
The first six columns of \eqref{eqn:nbcLinearSystem} will be represented by $\vec{J}_{n}$.
The next $N_{f}$ columns, the inter-continuity coupling columns, will be represented by $\vec{K}_{n}$.
The final $6 * N_{\text{NBC}}$ columns, representing the inter-domain flow rate coefficients, will be collectively referred to as $\vec{Q}_{n}$.
This matrix, $\vec{Q}_{n}$, is also present with the opposite sign on the right hand side of \eqref{eqn:nbcLinearSystem}.
Using this matrix notation, \eqref{eqn:nbcLinearSystem} can be represented as \eqref{eqn:nbcLinSystem}.

\begin{equation}
\label{eqn:nbcLinSystem}
\left[ \vec{J}_{n} \vert \vec{K}_{n} \vert \vec{Q}_{n} \right] \delta \vec{C}_{j} = \left[\vec{r}_{n} \vert -\vec{Q}_{n}\right]
\end{equation}

This rectangular linear system for the nonlinear boundary volume is then subjected to partial $\vec{LU}$ decomposition without pivoting.

\begin{equation}
\label{eqn:nbcLUSystem}
\left[ \vec{U}_{n} \vert \vec{L}^{-1}_{n}\vec{K}_{n} \vert \vec{L}^{-1}_{n}\vec{Q}_{n} \right] \delta \vec{C}_{j} = \left[\vec{L}^{-1}_{n}\vec{r}_{n} \vert -\vec{L}^{-1}_{n}\vec{Q}_{n}\right]
\end{equation}

However, since product of $\vec{L}_{n}^{-1}\vec{Q}_{n}$ occurs twice in the resulting system, only a single instance is included in the solution of this system.
The $\vec{Q}_{n}$ is omitted from the right-hand side of \eqref{eqn:nbcLinSystem} during the $\vec{LU}$ decomposition.
This $\vec{LU}$ decomposition is such that the lower triangular matrix has ones along the diagonal.
The $N_{\text{NBC}}$ identity matrices in $\vec{Q}_{n}$ are now themselves the inverse of the lower triangular matrix times \dt{}.
The final row of the linear system in \eqref{eqn:nbcLUSystem} is then scaled by $\vec{U}_{n}[6,6]$.

The linear pressure matrix is assembled with the sixth row from each continuity volume in the linear domain including the NBC volumes.
There will be $N_{l}$ rows in the system that correspond to each of the linear pressure updates.
Let $N_{n}$ represent the total number of interfaces between the linear and the nonlinear domains.
There will be an additional $6 * N_{n}$ left-hand and right-hand sides for the linear pressure matrix that correspond to the coefficient matrices, $\vec{L}^{-1}_{n}\vec{Q}_{n}$, for the unknown flow rates in each of the NBC volumes.
Once the system has been inverted, the resulting pressure updates for the linear domain are functions of the unknown flow rates between the domains, as shown in \eqref{eqn:linearDomainPressureUpdates}.

\begin{equation}
\label{eqn:linearDomainPressureUpdates}
\delta \vec{P} + \sum_{i\,=\,1}^{N_{n}} \sum_{e\,=\,1}^{6} \vec{w}_{i, e} \delta \Psi_{i, e} = \delta \vec{P}^{*} 
\end{equation}

The vectors $\vec{w}_{i, e}$ represent the coupling coefficients for each nonlinear boundary volume's pressure update.
The pressure update represented in \eqref{eqn:linearDomainPressureUpdates} is taken to be $\delta \vec{P} = \vec{P}^{n+1} - \vec{P}^{n}$.
This interpretation comes from the definition of the linear domain.
In the linear domain a single Newton step is taken to be the change from the old-time solution to the new-time solution, not an iterate.

Once the linear system has been inverted, the nonlinear pressure matrix is finalized.
Recall that the nonlinear continuity volumes are not modified by the domain decomposition.
The nonlinear domain is composed of $N_{\text{nln}}$ continuity volumes.
For each nonlinear boundary volume, there will be an additional row in the nonlinear pressure matrix.
The final nonlinear pressure matrix will have $N_{\text{nln}} + N_{n}$ equations and unknowns.
This matrix is then inverted to obtain the tentative new-time values for the nonlinear domain.
The nonlinear domain is then subjected to multiple Newton iterates as outlined in \sect{sect:nlnCobraSolver}.
The norms used for convergence determination are formulated from the residuals and updates from the nonlinear domain only.

Upon completion of the Newton iterations for the nonlinear domain, the linear domain is then subjected to the update.
All pressure updates are functions of the inter-domain flow rates, which are now known.
These flow rates are used to obtain the correct pressure updates.
Once those pressure updates are obtained, the entire linear domain is looped over, where the linear updates are obtained.
The completion of the linear update marks the completion of a single time-step.

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\section{Implementation in \cobra{}}
\label{sec:dd_algo}

The domain decomposition method outlined in \sect{sec:domDecompMath} was integrated into the \cobra{} software.
In this section, several architectural changes that were necessary to implement the domain decomposition are outlined.
First, the modification of how the solvers are structured is discussed.
Second, the implementation of an object-oriented domain system for proper domain identification is detailed.
Then the algorithmic implementation of the domain decomposition method will be shown in detail.
Lastly, the dual domain input file is described.

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\subsection{Pressure Matrix Data Structures}
\label{subsect:domDecompSolverStructs}

As seen in \sect{sect:linCobraAlg}, the largest linear system that is solved during a Newton step is the pressure matrix that is used to obtain the pressure update vector.
\cobra{} provides the user with three options for the linear algebra method to be used for solving for the pressure update: the Gauss elimination routine, the SuperLU solver \cite{Li1999}, and the Pardiso solver \cite{Schenk2006, Schenk2007}.
The SuperLU and the Pardiso solvers utilize sparse matrix storage and the Gauss elimination routine utilizes a full matrix.
The sparsity of the matrices typically encountered are such that use of the direct solver is discouraged.

The method that the user selects via the \cobra{} input file, ``\classname{deck.inp}" determines the data storage structure of the pressure matrix.
Each of the three methods utilizes a different memory format for matrix storage.
Given that the original software was based upon procedural programming practices and written in a mixed Fortran dialect (FORTRAN 77, Fortran 90, and Fortran 95), the static memory structures for each of the three possible pressure matrices were predefined in different modules.
However, this procedural paradigm precluded the existence of two separate pressure matrices, one for the linear domain and one for the nonlinear domain.
This procedural approach for the pressure matrices was deemed to be inappropriate for the work being done.
The way in which the solver was stored and accessed was modified to both enable multiple solvers and reduce the logical complexity of accessing the proper matrix.

\begin{figure}[ht!]
\singlespace\centering
\input{images/matrixClassDiagram}
\caption{Matrix Class Diagram}
\label{fig:matrixClassDiagram}
\end{figure}

The object-oriented features in Fortran 2003/2008 standards provided an alternative method of handling the pressure matrix.
The matrix storage structure was first replaced with an abstract class, \classname{matrix}.
The \classname{matrix} class contains the number of right hand sides anticipated as well as the total number of pressure updates for a given domain, $N$.
Additionally, this class would provide interfaces for the following procedures:

\begin{itemize}
\item{put : a procedure that sets $\vec{A}_{i,j}$ to a given value.}
\item{get : a procedure that returns $\vec{A}_{i,j}$.}
\item{scale : a procedure for scaling $\vec{A}_{i, :}$ by a given value.}
\item{reset : a procedure for setting $\vec{A} = \vec{0}$.}
\item{invert : a procedure that returns $\vec{x}$ from $\vec{A}\vec{x} = \vec{b}$.}
\end{itemize}

Given that the SuperLU and the Pardiso solvers utilize sparse matrices and the Gauss elimination routine uses a full matrix, there are two further abstract classes that inherit from \classname{matrix}; they are \classname{fullMatrix} and \classname{sparseMatrix}.
The \classname{fullMatrix} class contains an array representing $\vec{A}$.
The \classname{sparseMatrix} class contains the information required to construct a sparse matrix; however, the exact storage format is not specified in \classname{sparseMatrix}.
Both \classname{fullMatrix} and \classname{sparseMatrix} contain procedural implementations of the interfaces defined in \classname{matrix}.
There are three concrete classes that correspond to the three supported solvers: \classname{dsolveMatrix}, \classname{superluMatrix}, and \classname{pardisoMatrix}; all three implement their own linear system solving routines under the invert interface.
\classname{dsolveMatrix} is a concrete class inheriting from \classname{fullMatrix} that includes pivoting information.
\classname{superluMatrix} and \classname{pardisoMatrix} are concrete classes inheriting from \classname{sparseMatrix} that implement the matrix storage schemes for their respective solvers.
\fig{fig:matrixClassDiagram} shows the class diagram for the \classname{matrix} ecosystem.

\begin{figure}[ht!]
\singlespace\centering
\input{images/solverClassDiagram}
\caption{Solver Class Diagram}
\label{fig:solverClassDiagram}
\end{figure}

Once the \classname{matrix} ecosystem was developed, an abstract \classname{solver} class was designed.
The \classname{solver} class contains the size of the system, $N_{a}$; a pointer to a \classname{matrix} object, $\vec{A}$; and the right hand side of the linear system, \classname{res}.
Within the \classname{solver} class there is an interface for the initialization routine, \classname{init}.
In addition, the following procedures for manipulating the linear system are defined:

\begin{itemize}
\item{ \classname{insert} : a procedure for inserting the a continuity \classname{volume}'s pressure equation into $\vec{A}_{i, :}$.}
\item{ \classname{solve} : an interface to call the solver associated with the matrix.}
\item{ \classname{scale} : a procedure for scaling $\vec{A}_{i, :}$ and $\vec{res}_{i}$.}
\item{ \classname{reset} : a procedure for setting $\vec{A} = \vec{0}$ and $\vec{res} = \vec{0}$.}
\end{itemize}

There are three concrete classes that inherit from the abstract solver class: \classname{dsolveSolver}, \classname{superluSolver}, and \classname{pardisoSolver}.
Each of these concrete classes specifies an initialization routine that takes an adjacency list data structure, instantiates the \classname{matrix} pointer to the appropriate concrete subtype, and sets the appropriate parameters.
By abstracting the matrix storage strategies and the solvers in this way, a consistent interface is provided to the rest of the software.
\fig{fig:solverClassDiagram} shows the class diagram for the \classname{solver} ecosystem.

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\subsection{Volume Data Structures}
\label{subsect:domDecompVolumeStructs}

A difficulty that had to be overcome during this work was indexing.
The memory storage format for many variables was based upon a universal ordinal system for the continuity volumes.
This ordinal system was based upon the premise that there was a single pressure matrix.
It was determined that programmatic complexity of trying to maintain a single ordinal system for the dual domains was greater than that of redesigning the memory architecture.
As part of the redesign, the software was partially transitioned to an object-based mesh.

A continuity volume was chosen as the basic unit for mesh representation.
Given that the mesh is decomposed into dual domains, there were two types of continuity volumes that needed to be distinguished.
The first type of volume includes all continuity volumes in the nonlinear domain and those continuity volumes in the linear domain that do not have a flowpath connecting them to the nonlinear domain.
The second type of volume includes those continuity volumes in the linear domain that have a flowpath connecting them to the nonlinear domain.
The volume class diagram for \cobra{} is outlined in \fig{fig:volumeClassDiagram}.

\begin{figure}[ht!]
\singlespace\centering
\input{images/volumeClassDiagram}
\caption{Volume Class Diagram}
\label{fig:volumeClassDiagram}
\end{figure}

The basic continuity volume class is the \classname{baseVolume} class.
This class contains basic connectivity information for the continuity volume.
Each \classname{baseVolume} object has a pointer to the \classname{solver} object associated with its domain.
A \classname{baseVolume} that corresponds to a continuity volume in the linear domain has a \classname{solver} pointer to the solver for linear pressure matrix.
The nonlinear domain's continuity volumes have a \classname{solver} pointer to the solver for the nonlinear pressure matrix.
This allows each continuity volume to be able to access the correct pressure matrix without having to reference a logical map or perform a calculation.
In addition to the solver, the volume's ordinal is stored.
This variable provides indexing information for the volume's pressure matrix.

Additionally, information regarding the connectivity of the volume to other volumes is stored in several variables: \classname{num\_cons}, \classname{cons}, \classname{con\_type}, \classname{con\_ord}, \classname{gap\_ord}, \classname{con\_coords}, \classname{fp\_coords}, and \classname{con\_sig}.
These variables represent the information necessary to properly references those flowpaths to which the continuity volume is connected as well as the continuity volumes on the other end of the flowpaths.
This data structure has the drawback of storing redundant flowpath information.
Each of the continuity volumes connected by a particular flowpath contain all of the information about that flowpath in separate memory locations.
sThis issue is known, and its resolution is part of ongoing development work of \cobra{}.

The \classname{volume} also contains the Jacobian matrix and the right hand sides from \sect{sect:linCobraAlg}.
The local Jacobian matrix $\vec{J}_{c, j}$ is stored as \classname{jac}.
The right hand side of the continuity volume's linear system, $\vec{F}_{c, j}$, is stored as \classname{b}.
The variable \classname{b\_ords} provides a mapping between the local continuity volume's residual and flow rate coefficients to the global pressure matrix's ordinals.

Those linear continuity volumes that are connected to the nonlinear domain via a flowpath have their own \classname{nbcVolume} class.
This class, as shown in \fig{fig:volumeClassDiagram}, contains the additional information required to perform the domain decomposition.
First, a second \classname{solver} pointer is present, \classname{nln\_solver}.
This allows for proper indexing into the nonlinear pressure matrix when needed.
Second, the \classname{nbcVolume} also contains a separate collection of variables describing those flowpaths that connect it to the nonlinear domain: \classname{nbc\_cons}, \classname{nbc\_con\_ord}, \classname{nbc\_con\_map}, \classname{nbc\_ords}, \classname{nbc\_coords}, \classname{coords}, and \classname{nln\_ord\_by\_local\_nbc\_ord}.
Lastly, the \classname{nbcVolume} class also contains the pressure coefficients, \classname{coef\_mat}; the flow rate associated with the boundary, \classname{flux}; the derivative of the flow rate with respect to the pressure on either side of the flowpath, \classname{dflux\_dp}; the matrix $\vec{\Xi}$ in compressed storage, \classname{donored\_values}; and the right hand side of the linear domain's pressure solution, \classname{dp}.

Each continuity volume is represented by one of the above described \classname{volume} classes.
This polymorphic approach allows for domain-agnostic procedures and references within the software.

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\subsection{Domain Decomposition Algorithm}
\label{subsect:domDecompAlgorithm}

First, the nonlinear domain-decomposition input file described in \sect{subsect:domDecompInputFile} is parsed to determine in which domain each channel belongs.
Second, each continuity volume is designated as either a regular \classname{volume} or an {nbcVolume}.
Then the  \classname{solver} objects are instantiated according to the \cobra{} input file.
Lastly, after the input processing and state initialization, the temporal integration loop begins.

A single timestep is now broken into two parts, the linear and the nonlinear portions.
At the beginning of a timestep, the entire domain is traversed to assemble the pressure matrices for both the linear and the nonlinear domains.
This process is similar to the algorithm outlined in \ref{sect:linCobraAlg} for assembling the pressure matrix.
However, there are differences when a \classname{nbcVolume} is encountered.

For all the non-\classname{nbcVolume} continuity volumes, the following procedure is followed.
Each continuity volume's linearized system of equations, \eqref{eqn:linSystem}, is subjected to partial LU decomposition without pivoting.
The lower triangular matrix has a unit diagonal.
The sixth equation in the upper-triangular system is then scaled by its diagonal.
This upper-triangular rectangular system for each continuity volume is then stored for later back-substitution.
Since the pressure update corresponds to the last row in the system of equations, this allows for the isolation of the pressure updates.
The last row of each continuity volume's \eqref{eqn:linSystem} is then formed into a global pressure matrix, $\vec{A}_{N,N}$, and its associated right hand side, $\vec{r}$.

The two loops, one over the momentum volumes and one over the continuity volumes, form a single group of operations that act upon a given domain.
This grouping will be known hereafter as assembling the pressure matrix for a given domain.
\alg{alg:xschem} shows the two loops and their associated actions.

\begin{algo}[ht!]
\setlength{\baselineskip}{0.625\baselineskip}
\begin{algorithmic}[1]
\For{i = 1, $N_{\text{nln}}$}
	\Set $\text{b} \Rightarrow \text{nbcVolume[i].solver.res(nbcVolume[i].ord,:)}$
	\For{j = 1, $N_{\text{nln}}$}
		\For{ k = 1, nbcVolume[j].nbc\_cons}
			\Set g\_ord = nbcVolume[j].nbc\_con\_ord(k)
			\Set s\_ord = 2 + 6 $*$ (g\_ord - 1)
			\Set e\_ord = s\_ord + 5
			\Set nbcVolume[i].coef\_mat(1:6, g\_ord) = b(s\_ord:e\_ord)
		\EndFor
	\EndFor
\EndFor
\end{algorithmic}
\caption{Obtain Nonlinear Boundary Volume Coefficients.}
\label{alg:domDecompGetCoef}
\end{algo}

Each \classname{nbcVolume} is treated slightly differently.
The flow rate terms from the equations are not included in the residual at this point but, are instead treated as unknowns.
These flow rates are treated as independent parameters, which decreases the number of entries in the $\vec{C}_{j}$ matrix..
Additionally, the derivatives of the flow rate terms with respect to themselves, the identify matrix $\vec{I}$, are added to the linear system.
If a linear continuity volume is attached through more than one surface to the nonlinear domain, then there will be multiple identity matrices in the continuity volume's linear system.
The resulting system will be subjected to the same LU decomposition as outlined for a regular volume.
The last equation with the additional right hand sides will be assembled into the linear domains pressure matrix.
The linear system for the linear domain is inverted by the chosen solver.
The additional coefficients represent the coefficients for the boundary flow rate between the linear and the nonlinear domain.
After the inversion of the pressure matrix, the coefficients for the nonlinear boundary volumes are collected into the nonlinear boundary volumes for ease of manipulation later.
This is shown in \alg{alg:domDecompGetCoef}.

\begin{algo}[ht!]
\setlength{\baselineskip}{0.625\baselineskip}
\begin{algorithmic}[1]
\For{i = 1, $N_{\text{nln}}$}
	\Set A $\Rightarrow$ nbcVolume[i].nln\_solver.A
	\Set i\_ord = nbcVolume[i].nln\_ord
	\For{j = 1, $N_{\text{nln}}$}
		\Set j\_ord = nbcVolume[j].nln\_ord
		\For{ k = 1, nbcVolume[i].nbc\_cons}
			\Set g\_ord = nbcVolume[j].nbc\_con\_ord(k)
			\Set k\_ord = nbcVolume[j].nln\_ord\_by\_local\_nbc\_ord(k)
			\Set dp = nbcVolume[i].coef\_mat(:, g\_ord) $\cdot$ nbcVolume[j].dflux\_dp(:, k)
			\Set A(i\_ord, k\_ord) $\pluseq$ dp
			\Set A(i\_ord, j\_ord) $\minuseq$ dp
		\EndFor
	\EndFor
	\Set res = nbcVolume[i].solver.res(nbcVolume[i].ord,:) $\cdot$ nbc\_flux
	\Set nbcVolume[i].nln\_solver.res(i\_ord, 1) = res
	\Set A(i\_ord, i\_ord) $\pluseq$ 1.0
	\State \textbf{call:} nbcVolume[i].nln\_solver.rescale(i\_ord)
\EndFor
\end{algorithmic}
\caption{Set Nonlinear Boundary Volume Pressure Equations Into Nonlinear Pressure Matrix.}
\label{alg:domDecompSetMat}
\end{algo}

Now that the coefficients have been collected and the linear domain has been inverted, the additional entries in the nonlinear pressure matrix that represent the boundary pressures are populated.
This population is accomplished by looping over all the nonlinear boundary volumes.
Each nonlinear boundary volume has an associated pressure equation.
Due to the inversion of the linear domain's pressure matrix, the pressure equation of each nonlinear boundary volume now has a dependence upon all other nonlinear boundary volumes and the nonlinear volumes to which they attach.
This creates a second loop inside of the outer loop that loops over all the nonlinear boundary volumes again.
Within this loop there is a third loop that goes over all of the interfaces that that volume has with the nonlinear domain.
This is a system of three nested loops.
The inner nonlinear boundary volume loop calculates the flow rate derivatives with respect to pressures. 
This process is shown in detail in \alg{alg:domDecompSetMat}.

Once the pressure equations for the nonlinear boundary volumes have been inserted in the nonlinear pressure matrix, the pressure matrix for the nonlinear domain is solved.
The resulting pressure update vector is then used to update the nonlinear continuity volumes' variables according to \alg{alg:updateVariables}.
The Newton loop is now entered.
This loop is similar to that discussed in \sect{sect:nlnCobraSolver}, with the addition of a step to set the nonlinear boundary volumes' equations.
Upon termination of the Newton loop, the linear domain's variables are updated.

\begin{algo}[ht!]
\setlength{\baselineskip}{0.625\baselineskip}
\begin{algorithmic}[1]
\Require $\vec{x}^{0}$ and $t^{0}$
\Set $n = 0$
\Loop \; Transient Loop
    \Set $t^{n+1} : = t^{n} + \dt{}$
	\Algorithm Assemble Nonlinear and Linear Pressure Matrices	 \Comment{\alg{alg:xschem}}
	\LineIf{ \classname{LinearSolver} }{\textbf{solve} $\vec{A}_{l} \vec{\delta P}_{l} = \vec{res}_{l}$}
	\If{ \classname{NonlinearSolver} }
	    \Set $k = 0$
		\Algorithm Get Nonlinear Coefficients \Comment{\alg{alg:domDecompGetCoef}}
		\Algorithm Set Nonlinear Boundary Values \Comment{\alg{alg:domDecompSetMat}}
		\Solve $\vec{A}^{k}_{n} \vec{\delta P}_{n}^{k} = \vec{res}_{n}^{k}$	
		\Algorithm Update Nonlinear Variables \Comment{\alg{alg:updateVariables}} 
	    \Loop \; Newton Loop
			\Algorithm Assemble Nonlinear Pressure Matrix \Comment{\alg{alg:xschem}}
			\Algorithm Nonlinear Convergence Determination \Comment{\alg{alg:nlnConvergence}}
			\If{ \textbf{end} Newton loop}
				\State Undo partial Newton Step
				\State \textbf{break} Newton Loop 
			\EndIf		
			\Set $k \pluseq 1$
			\Algorithm Set Nonlinear Boundary Values \Comment{\alg{alg:domDecompSetMat}}
			\Solve $\vec{A}^{k} \vec{\delta P}^{k} = \vec{res}^{k}$
			\Algorithm Update Nonlinear Variables \Comment{\alg{alg:updateVariables}}
		\EndLoop
	\EndIf
	\LineIf{ \classname{LinearSolver} }{\textbf{algorithm} Update Linear Variables} \Comment{\alg{alg:updateVariables}}
	\Set $n \pluseq 1$
\EndLoop
\end{algorithmic}
\caption{Dual domain \cobra{} algorithm.}
\label{alg:domDecompAlgorithm}
\end{algo}

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\subsection{Dual Domain Input File}
\label{subsect:domDecompInputFile}

In order to activate the spatially selective nonlinear solver, the nonlinear solver input file needs to have additional information.
The ID of the channels that are going to be subjected to additional Newtons steps needs to be specified.
The basic nonlinear convergence is still input as described in \sect{subsect:nlnCobraInputFile}.
The nonlinear convergence tolerances and iteration limit only apply to the nonlinear domain.
However, there is now additional information appended to the basic nonlinear input.
The presence of the character string ``'begin-nln-channels'" after the nonlinear input signals that there will be two domains.
After that string, the ID of the channels are listed, one per line, in no particular order.
Once all channels to be in the nonlinear domain have been listed, the character string ``'end-nln-channels'" needs to be on a separate line.
The following is an example of the dual domain input segment of the ``\classname{nwt.cob}" input file.

{
\singlespace
\begin{verbatim}
'begin-nln-channels'
<chanID_1>
<chanID_2>
<chanID_3>
...
<chanID_N>
'end-nln-channels'
\end{verbatim}
}

In the above example, <chanID\_N> is the channel ID that will be included in the nonlinear domain.
The input processing routine has extensive error checking and user feedback for proper formatting of this input.
Note that there is no requirement that the channels specified to be in the nonlinear domain form a contiguous domain.


