\chapter{Domain Decomposition}
\label{chap:domain_decomposition}
The governing partial differential equations described in \sect{subsect:governing_equations} contain nonlinearities that are distributed in both space and time.
In the absence of nonlinear physics a single Newton step is adequate to solve the governing set of discrete algebraic equations.
However, for a given spatial mesh when nonlinearities are present if the number of Newton steps is limited to one, then the only way to resolve those nonlinearities is to refine the temporal discretization.
If the number of Newton steps is not limited to one, then the nonlinearities may be resolved for a fixed temporal discretization.
When the nonlinearities are isolated to a given nonlinear portion of the domain, the additional Newton steps do not improve the solution in the linear portion of the domain.
The ability to resolve the nonlinear physics only where they occur could potentially provide a way to reduce the computational cost associated with resolving the nonlinear error for a given timestep.
The following section contains three sections that describe the mathematical formulation of the domain decomposition, a description of its implementation, and several problems that were used to verify that the algorithm had been implemented properly.

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\section{Mathematical Formulation}
\label{sec:dd_math}

\cobra{} uses a staggered mesh to represent the computational domain.
The domain decomposition takes place within the context of a Newton step.
The starting place for the formulation will be the continuity equations for a generic volume,  \fig{fig:single_volume}.
The edges of the volume will be labeled $x_{j \pm \onehalf}$.
Without loss of generality, the following formulation will have advection only in one spatial dimension and will not contain the terms associated with the exchange of mass and energy between the different fields and phases.
The convection in this work is that the normal vector for a given volume will be outwards directed.
A positive flow corresponds to flow in the direction of increasing $x_{j}$.  

The corresponding continuity equations for a given volume are then given by \eqref{eqn:advection_of_ncg_mass} -- \eqref{eqn:advection_of_vap_mass}.

\begin{IEEEeqnarray}{rCl}
\label{eqn:advection_of_ncg_mass}
V_{c,j}\frac{(\alpha_{g} \rho_{n})^{n+1, k}_{j} - (\alpha_{g} \rho_{n})^{n}_{j} }{ \dt{} } + \dot{m}^{n+1, k}_{g, j + \onehalf}\frac{\don{\alpha^{n}_{g} \rho^{n}_{n}}^{n+1,k}_{d, j+\onehalf}}{\ave{\alpha_{g} \rho_{g}}^{n}_{a, j + \onehalf}} - \dot{m}^{n+1, k}_{g, j - \onehalf}\frac{\don{\alpha^{n}_{g} \rho^{n}_{n}}^{n+1,k}_{d, j-\onehalf}}{\ave{\alpha_{g} \rho_{g}}^{n}_{a, j - \onehalf}} & = & 0 \\
%
\label{eqn:advection_of_liq_mass}
V_{c,j}\frac{(\alpha_{l} \rho_{l})^{n+1, k}_{j} - (\alpha_{l} \rho_{l})^{n}_{j} }{ \dt } + \dot{m}^{n+1, k}_{l, j + \onehalf}\frac{\don{ \alpha^{n}_{l} \rho^{n}_{l} }^{n+1,k}_{d, j+\onehalf}}{\ave{\alpha_{l} \rho_{l}}^{n}_{a, j + \onehalf}} - \dot{m}^{n+1, k}_{l, j - \onehalf}\frac{\don{\alpha^{n}_{l} \rho^{n}_{l}}^{n+1,k}_{d, j-\onehalf}}{\ave{\alpha_{l} \rho_{l}}^{n}_{a, j - \onehalf}} & = & 0 \\
%
\label{eqn:advection_of_gas_energy}
V_{c,j}\frac{(\alpha_g \rho_g h_g)^{n+1, k}_{j} - (\alpha_g \rho_g h_g)^{n}_{j} }{ \dt } + \dot{m}^{n+1, k}_{g, j + \onehalf}\frac{\don{\alpha^n_g \rho^n_g h^{n}_{g}}^{n+1,k}_{d, j+\onehalf}}{\ave{\alpha_{g} \rho_{g}}^{n}_{a, j + \onehalf}} - \dot{m}^{n+1, k}_{g, j - \onehalf}\frac{\don{\alpha^{n}_{g} \rho^{n}_{g} h^{n}_{g}}^{n+1,k}_{d, j-\onehalf}}{\ave{\alpha_{g} \rho_{g}}^{n}_{a, j - \onehalf}} &  & \\
%
\nonumber
- V_{c,j} \alpha^{n}_{g} \frac{P^{\, n+1, k}_{j} - P^{\,n}_{j} }{\dt{}} & = & 0 \\
\label{eqn:advection_of_liq_energy}
V_{c,j}\frac{(\alpha_{l} \rho_{l} h_{l})^{n+1, k}_{j} - (\alpha_{l} \rho_{l} h_{l} )^{n}_{j} }{ \dt } + \dot{m}^{n+1, k}_{l, j + \onehalf}\frac{\don{\alpha^{n}_{l} \rho^{n}_{l} h^{n}_{l} }^{n+1, k}_{d, j+\onehalf}}{\ave{\alpha_{l} \rho_{l}}^{n}_{a, j + \onehalf}} - \dot{m}^{n+1, k}_{l, j - \onehalf}\frac{\don{\alpha^{n}_{l} \rho^{n}_{l} h^{n}_{l}}^{n+1, k}_{d, j-\onehalf}}{\ave{\alpha_{l} \rho_{l}}^{n}_{a, j - \onehalf}} &  &  \\
%
\nonumber
+ \dot{m}^{n+1, k}_{e, j + \onehalf}\frac{\don{\alpha^{n}_{e} \rho^{n}_{l} h^{n}_{l}}^{n+1, k}_{d, j+\onehalf}}{\ave{\alpha_{e} \rho_{l}}^{n}_{a, j + \onehalf}} - \dot{m}^{n+1, k}_{e, j - \onehalf}\frac{\don{\alpha^{n}_{e} \rho^{n}_{l} h^{n}_{l}}^{n+1, k}_{d, j-\onehalf}}{\ave{\alpha_{e} \rho_{l}}^{n}_{a, j - \onehalf}} - V_{c,j} ( 1 - \alpha^{n}_{g})\frac{P^{\, n+1, k}_{j} - P^{\,n}_{j} }{\dt{}}& = & 0 \\
%
\label{eqn:advection_of_ent_mass}
V_{c,j}\frac{(\alpha_{e} \rho_{l})^{n+1, k}_{j} - (\alpha_{e} \rho_{l})^{n}_{j} }{ \dt } + \dot{m}^{n+1, k}_{e, j + \onehalf}\frac{\don{\alpha^{n}_{e} \rho^{n}_{l}}^{n+1,k}_{d, j+\onehalf}}{\ave{\alpha_{e} \rho_{l}}^{n}_{a, j + \onehalf}} - \dot{m}^{n+1, k}_{e, j - \onehalf}\frac{\don{\alpha^{n}_{e} \rho^{n}_{l}}^{n+1,k}_{d, j-\onehalf}}{\ave{\alpha_{e}\rho_{l}}^{n}_{a, j - \onehalf}} & = & 0 \\
%
\label{eqn:advection_of_vap_mass}
V_{c,j}\frac{(\alpha_{g} \rho_{v})^{n+1, k}_{j} - (\alpha_{g} \rho_{v})^{n}_{j} }{ \dt } + \dot{m}^{n+1, k}_{g, j + \onehalf}\frac{\don{\alpha^{n}_{g} \rho^{n}_{v}}^{n+1,k}_{d, j+\onehalf}}{\ave{\alpha_{g} \rho_{g}}^{n}_{a, j + \onehalf}} - \dot{m}^{n+1, k}_{g, j - \onehalf}\frac{\don{\alpha^{n}_{g} \rho^{n}_{v}}^{n+1,k}_{d, j-\onehalf}}{\ave{\alpha_{g} \rho_{g}}^{n}_{a, j - \onehalf}} & = & 0
\end{IEEEeqnarray}

It will be advantageous to a matrix, $\vec{\Xi}$, that converts the momenta at a continuity volume's edge to fluxes of mass and energy; \eqref{eqn:flux_matrix} will serve this purpose.

\begin{equation}
\label{eqn:flux_matrix}
\vec{\Xi}^{n+1, k}_{j \pm \onehalf} = \begin{bmatrix}
%
 0 & \frac{\don{\alpha^{n}_{g} \rho^{n}_{n}}^{n+1,k}_{d}}{\ave{\alpha_{g} \rho_{g}}^{n}_{a}} & 0 \\
%
\frac{\don{\alpha^{n}_{l}\rho^{n}_{l}}^{n+1,k}_{d}}{\ave{\alpha_{l} \rho_{l}}^{n}_{a}} & 0 & 0 \\
%
0 & \frac{\don{\alpha^{n}_{g} \rho^{n}_{g} h^{n}_{g}}^{n+1,k}_{d}}{\ave{\alpha_{g} \rho_{g}}^{n}_{a}} & 0 \\
%
\frac{\don{\alpha^{n}_{l}\rho^{n}_{l} h^{n}_{l}}^{n+1,k}_{d}}{\ave{\alpha_{l} \rho_{l}}^{n}_{a}} & 0 & \frac{\don{\alpha^{n}_{e} \rho^{n}_{l} h^{n}_{l}}^{n+1, k}_{d}}{\ave{\alpha_{e} \rho_{l}}^{n}_{a}} \\
%
0 & 0 & \frac{ \don{\alpha^{n}_{e} \rho^{n}_{l}}^{n+1, k}_{d}}{ \ave{\alpha_{e} \rho_{l}}^{n}_{a}} \\
%
0 & \frac{ \don{\alpha^{n}_{g} \rho^{n}_{v}}^{n+1, k}_{d}}{ \ave{\alpha_{g} \rho_{g}}^{n}_{a}} & 0
\end{bmatrix}_{j \pm \onehalf}
\end{equation}

The momenta vector is given by \eqref{eqn:momenta_vector}.

\begin{equation}
\label{eqn:momenta_vector}
\vec{\dot{m}} = \begin{bmatrix}
\dot{m}_{l} \\
\dot{m}_{g} \\
\dot{m}_{e}
\end{bmatrix}
\end{equation}

The fluxes into or out of a given volume will be denoted by $\vec{\Psi}$, \eqref{eqn:flux_vector}.

\begin{equation}
\label{eqn:flux_vector}
\vec{\Psi} = \vec{\Xi} \cdot \vec{\dot{m}}
\end{equation}

With \eqref{eqn:flux_matrix} through \eqref{eqn:flux_vector}, \eqref{eqn:advection_of_ncg_mass} -- \eqref{eqn:advection_of_vap_mass} can be written as the vector of equations \eqref{eqn:short_hand_continuity}.

\begin{equation}
\label{eqn:short_hand_continuity}
\frac{V_j}{\dt} \begin{bmatrix}
(\alpha_{g} \rho_{n})^{n+1, k}_{j} - (\alpha_{g} \rho_{n})^{n}_{j} \\
\alpha_{l} \rho_{l})^{n+1, k}_{j} - (\alpha_{l} \rho_{l})^{n}_{j} \\
(\alpha_{g} \rho_{g} h_{g})^{n+1, k}_{j} - (\alpha_{g} \rho_g h_{g})^{n}_{j} - \alpha^{n}_{g} ( P^{\, n+1, k}_{j} - P^{\,n}_{j} )  \\
(\alpha_{l} \rho_{l} h_{l})^{n+1, k}_{j} - (\alpha_{l} \rho_{l} h_{l} )^{n}_{j} - (1 - \alpha^{n}_{g}) ( P^{\, n+1, k}_{j} - P^{\,n}_{j} )\\
(\alpha_{e} \rho_{l})^{n+1, k}_{j} - (\alpha_{e} \rho_{l})^{n}_{j} \\
(\alpha_{g} \rho_{v})^{n+1, k}_{j} - (\alpha_{g} \rho_{v})^{n}_{j} 
\end{bmatrix} + \vec{\Psi}^{n+1, k}_{j + \onehalf} - \vec{\Psi}^{n+1, k}_{j - \onehalf}= 0
\end{equation}

The residuals of the continuity equations at a given point, \eqref{eqn:short_hand_continuity}, will be known as $\vec{F}_{c, j}$.
Let the Jacobian of \eqref{eqn:short_hand_continuity} with respect to the associated nonlinear parameters as defined in \eqref{eqn:independentVariables} be defined as $J^{k}_{c, j}$.
The Jacobian of \eqref{eqn:short_hand_continuity} with respect to adjacent momenta, \eqref{eqn:momenta_vector}, is given by $\vec{\Xi}^{k}_{c, j \pm \onehalf}$.
The domain decomposition method is based upon fluxes into and out of a domain.

Up to this point, the discussion of the linear and nonlinear algorithms have avoided the use of full nonlinear system.
However, it is now time to venture into unknown territories.
For this example, imagine the following model:

\comment{HERE THERE IS A PICTURE OF TWO VOLUMES VERTICALLY CONNECTED.}

The following procedure will show the development of a single domain newton step.

\begin{equation}
\label{eqn:domainMatrix}
 \begin{bmatrix} 
\vec{J}_{c_1} & \vec{\Xi}_{c_1,m_1} & \vec{0} \\
\vec{J}_{m_1,c_1} & \vec{J}_{m_1} & \vec{J}_{m_1,c_2}  \\
\vec{0} & \vec{\Xi}_{c_2,m_1} & \vec{J}_{c_2} \\
 \end{bmatrix} \begin{bmatrix}
 \vec{\delta c}_{1} \\
 \vec{\delta m}_{1} \\
 \vec{\delta c}_{2} \\
\end{bmatrix}  = -\begin{bmatrix}
 \vec{F}_{c_1} \\
 \vec{F}_{m_1} \\
 \vec{F}_{c_2} \\
\end{bmatrix}
 \end{equation}
 
 \begin{equation}
\label{eqn:domainMatrix2}
 \begin{bmatrix} 
\vec{J}_{c_1} & \vec{\Xi}_{c_1,m_1} & \vec{0} \\
\frac{\partial \dot{\vec{m}}_{1}}{\partial P_{1} } & \vec{I} & \frac{\partial \dot{\vec{m}}_{1}}{\partial P_{2} }  \\
\vec{0} & \vec{\Xi}_{c_2,m_1} & \vec{J}_{c_2} \\
 \end{bmatrix} \begin{bmatrix}
 \vec{\delta c}_{1} \\
 \vec{\delta m}_{1} \\
 \vec{\delta c}_{2} \\
\end{bmatrix}  = \begin{bmatrix}
 - \vec{F}_{c_1} \\
 \delta \dot{\vec{m}}^{*} \\
 - \vec{F}_{c_2} \\
\end{bmatrix}
 \end{equation}
 
  
 \begin{equation}
\label{eqn:domainMatrix3}
 \begin{bmatrix} 
\vec{I} & \frac{\partial \dot{\vec{m}}_{1}}{\partial P_{1} } & \frac{\partial \dot{\vec{m}}_{1}}{\partial P_{2} }  \\
\vec{0} & \vec{J}_{c_1} - \vec{\Xi}_{c_1,m_1} \frac{\partial \dot{\vec{m}}_{1}}{\partial P_{1} } & - \vec{\Xi}_{c_1,m_1} \frac{\partial \dot{\vec{m}}_{1}}{\partial P_{2} }  \\
\vec{0} & -\vec{\Xi}_{c_2,m_1}\frac{\partial \dot{\vec{m}}_{1}}{\partial P_{1} } & \vec{J}_{c_2} - \vec{\Xi}_{c_2,m_1}\frac{\partial \dot{\vec{m}}_{1}}{\partial P_{2} } \\
 \end{bmatrix} \begin{bmatrix}
 \vec{\delta m}_{1} \\
 \vec{\delta c}_{1} \\
 \vec{\delta c}_{2} \\
\end{bmatrix}  = \begin{bmatrix}
 \delta \dot{\vec{m}}^{*} \\
 - ( \vec{F}_{c_1} + \vec{\Xi}_{c_1,m_1} \delta \dot{\vec{m}}^{*} ) \\
 - ( \vec{F}_{c_2} + \vec{\Xi}_{c_2,m_1} \delta \dot{\vec{m}}^{*} )\\
\end{bmatrix}
 \end{equation}

 \begin{equation}
\label{eqn:domainMatrix4}
 \begin{bmatrix} 
\vec{U}_{c_1} & - \vec{L}_{c_1}^{-1} \vec{\Xi}_{c_1,m_1} \frac{\partial \dot{\vec{m}}_{1}}{\partial P_{2} }  \\
-\vec{L}_{c_2}^{-1} \vec{\Xi}_{c_2,m_1}\frac{\partial \dot{\vec{m}}_{1}}{\partial P_{1} } & \vec{U}_{c_2} \\
 \end{bmatrix} \begin{bmatrix}
 \vec{\delta c}_{1} \\
 \vec{\delta c}_{2} \\
\end{bmatrix}  = \begin{bmatrix}
 - \vec{L}_{c_1}^{-1} ( \vec{F}_{c_1} + \vec{\Xi}_{c_1,m_1} \delta \dot{\vec{m}}^{*} ) \\
 - \vec{L}_{c_2}^{-1} ( \vec{F}_{c_2} + \vec{\Xi}_{c_2,m_1} \delta \dot{\vec{m}}^{*} )\\
\end{bmatrix}
 \end{equation}
 
  \begin{equation}
\label{eqn:domainMatrix5}
 \begin{bmatrix} 
1 & c_{1,2}  \\
c_{2,1} & 1 \\
 \end{bmatrix} \begin{bmatrix}
 \delta P_{1} \\
 \delta P_{2} \\
\end{bmatrix}  = \begin{bmatrix}
 f_1 \\
 f_2 \\
\end{bmatrix}
 \end{equation}
 
 The following is the domain decomposition version.
 
 \begin{equation}
\label{eqn:domainDecomp0}
 \begin{bmatrix} 
\vec{J}_{c_1} & \vec{\Xi}_{c_1,m_1} & \vec{0} \\
\vec{J}_{m_1,c_1} & \vec{J}_{m_1} & \vec{J}_{m_1,c_2}  \\
\vec{0} & \vec{\Xi}_{c_2,m_1} & \vec{J}_{c_2} \\
 \end{bmatrix} \begin{bmatrix}
 \vec{\delta c}_{1} \\
 \vec{\delta m}_{1} \\
 \vec{\delta c}_{2} \\
\end{bmatrix}  = -\begin{bmatrix}
 \vec{F}_{c_1} \\
 \vec{F}_{m_1} \\
 \vec{F}_{c_2} \\
\end{bmatrix}
 \end{equation}
 
 \begin{equation}
\label{eqn:domainDecomp1}
 \begin{bmatrix} 
\vec{J}_{c_1} & \vec{0} & - \vec{\Xi}_{m_1} & \vec{0} \\
\vec{0} & \vec{I} & \vec{\Xi}_{m_1} & 0 \\
\vec{J}_{m_1,c_1} & \vec{0} & \vec{J}_{m_1} & \vec{J}_{m_1,c_2}  \\
\vec{0} & \vec{0} & \vec{\Xi}_{m_1} & \vec{J}_{c_2} \\
 \end{bmatrix} \begin{bmatrix}
 \vec{\delta c}_{1} \\
 \vec{\delta \Psi}_{1} \\
 \vec{\delta m}_{1} \\
 \vec{\delta c}_{2} \\
\end{bmatrix}  = -\begin{bmatrix}
 \vec{F}_{c_1} \\
 \vec{0} \\
 \vec{F}_{m_1} \\
 \vec{F}_{c_2} \\
\end{bmatrix}
 \end{equation} 
 
 \begin{equation}
\label{eqn:domainDecomp2}
 \begin{bmatrix} 
\vec{J}_{c_1} & \vec{I} & \vec{0} & \vec{0} \\
\vec{0} & \vec{I} & \vec{\Xi}_{m_1} & 0 \\
\vec{J}_{m_1,c_1} & \vec{0} & \vec{J}_{m_1} & \vec{J}_{m_1,c_2}  \\
\vec{0} & \vec{0} & \vec{\Xi}_{m_1} & \vec{J}_{c_2} \\
 \end{bmatrix} \begin{bmatrix}
 \vec{\delta c}_{1} \\
 \vec{\delta \Psi}_{1} \\
 \vec{\delta m}_{1} \\
 \vec{\delta c}_{2} \\
\end{bmatrix}  = -\begin{bmatrix}
 \vec{F}_{c_1} \\
 \vec{0} \\
 \vec{F}_{m_1} \\
 \vec{F}_{c_2} \\
\end{bmatrix}
 \end{equation}
 
  
 \begin{equation}
\label{eqn:domainDecomp3}
 \begin{bmatrix} 
\vec{J}_{c_1} & \vec{I} & \vec{0} & \vec{0} \\
\vec{0} & \vec{I} & \vec{\Xi}_{m_1} & 0 \\
\frac{\partial \dot{\vec{m}}_{1}}{\partial P_{1} } & \vec{0} & \vec{I} & \frac{\partial \dot{\vec{m}}_{1}}{\partial P_{2} }  \\
\vec{0} & \vec{0} & \vec{\Xi}_{m_1} & \vec{J}_{c_2} \\
 \end{bmatrix} \begin{bmatrix}
 \vec{\delta c}_{1} \\
 \vec{\delta \Psi}_{1} \\
 \vec{\delta m}_{1} \\
 \vec{\delta c}_{2} \\
\end{bmatrix}  = \begin{bmatrix}
 - \vec{F}_{c_1} \\
 \vec{0} \\
 \delta \dot{\vec{m}}^{*} \\
 - \vec{F}_{c_2} \\
\end{bmatrix}
 \end{equation}

 \begin{equation}
\label{eqn:domainDecomp4}
 \begin{bmatrix} 
\vec{J}_{c_1} & \vec{I} & \vec{0} & \vec{0} \\
- \vec{\Xi}_{m_1}\frac{\partial \dot{\vec{m}}_{1}}{\partial P_{1} } & \vec{I} & \vec{0} & -\vec{\Xi}_{m_1}\frac{\partial \dot{\vec{m}}_{1}}{\partial P_{2} } \\
\frac{\partial \dot{\vec{m}}_{1}}{\partial P_{1} } & \vec{0} & \vec{I} & \frac{\partial \dot{\vec{m}}_{1}}{\partial P_{2} }  \\
\vec{0} & \vec{0} & \vec{\Xi}_{m_1} & \vec{J}_{c_2} \\
 \end{bmatrix} \begin{bmatrix}
 \vec{\delta c}_{1} \\
 \vec{\delta \Psi}_{1} \\
 \vec{\delta m}_{1} \\
 \vec{\delta c}_{2} \\
\end{bmatrix}  = \begin{bmatrix}
 - \vec{F}_{c_1} \\
 - \vec{\Xi}_{m_1} \delta \dot{\vec{m}}^{*} \\
 \delta \dot{\vec{m}}^{*} \\
 - \vec{F}_{c_2} \\
\end{bmatrix}
 \end{equation}
 
  \begin{equation}
\label{eqn:domainDecomp5}
 \begin{bmatrix} 
1 & c_{1,2}  \\
c_{2,1} & 1 \\
 \end{bmatrix} \begin{bmatrix}
 \delta P_{1} \\
 \delta P_{2} \\
\end{bmatrix}  = \begin{bmatrix}
 f_1 \\
 f_2 \\
\end{bmatrix}
 \end{equation}
 
\comment{
This is annoying as crap to describe.
I will give it a shot in words.
}

In order to active the spatially selective nonlinear solver, the nonlinear solver input file needs to have additional information.
The software needs to know which channels are going to be in the nonlinear domain.
As meantioned elsewhere \comment{maybe} the basic unit of domain decomposition is the channel.
Each channel has a user-specified ID.
The nonlinear input file described \comment{here} has the following appended to it:
'begin-nln-channels'
<chanID\_1>
<chanID\_2>
<chanID\_3>
...
<chanID\_N>
'end-nln-channels'
Where <chanID\_N> is the channel ID that will be included in the nonlinear domain.
There are no requirements that the channels specified to be nonlinear form a contiguous domain.
This input file specifies the channel id which will be subject to multiple Newton iterates.
The nonlinear tolerances and iterates apply to the nonlinear domain only.

The procedures that were written to determine which continuity volumes were active and which were inactive were modified to separate the domain in two: a liner and a nonlinear domain.

When formulating the governing equations, the fluxes between the linear and nonlinear domains are treated as additional nonlinear variables.
When the linear domain is formulated, these flux terms are treated as variational parameters within the continuity volumes in the linear domain that lie on the boundary of the nonlinear domain.
Take for example a continuity volume with only two flowpaths connected to it.
One flow path is connected to another continuity volume within the linear domain.
The other flow path is connected to a continuity volume that resides within the nonlinear domain.
When the Jacobian for these continuity volumes are taken, derivatives with respect to the flux terms are included.
Since the flux terms are single terms in the equations, their derivatives are the identity matrix.
The regular Jacobian is a six by six matrix.
With the single linear connection, there is now an additional columns representing the change in the continuity equations with respect to the momenta the linear volume edge, \eqref{eqn:flux_matrix}.
This matrix is eliminated through the use of \eqref{eqn:momStar}.
The final system of equations for a given nonlinear boundary volume is a six by six + 1 * number of linear connections + 6 * number of nonlinear boundary connections.
In this example the final size of the matrix will be 6 x 13.
\begin{equation}
\vec{J}|\vec{C}|\vec{I} = -(\vec{F} + \vec{\Psi})
\end{equation}
The six for the number of nonlinear boundary connections is equivalent to the flux of masses and energies.
The residual for the nonlinear boundary volume does not include the flux into the nonlinear domain.
This is omitted at this step to enable simpler algebra later.
This system is then reduced in-place to the upper-triangular rectangular form. 

\begin{equation}
\vec{U}|\vec{L}^{-1}\vec{C}|\vec{L}^{-1} = -\vec{L}^{-1}(\vec{F} + \vec{\Psi})
\end{equation}

The last equation in this row is then normalized by its diagonal entry.

\begin{equation}
\vec{U}|\vec{L}^{-1}\vec{C}|\vec{L}^{-1} = -\vec{L}^{-1}(\vec{F} + \vec{\Psi})
\end{equation}

The Jacobian for each entry is then stored for later use.

\begin{equation}
\label{eqn:jacobianWithFluxTerms}
\vec{J}_{c,j} = 
\begin{bmatrix}
\frac{\partial F_{m,n}}{\partial (\alpha_g P_{n})} & \frac{\partial F_{m,n}}{\partial \alpha_g } & \frac{\partial F_{m,n}}{\partial (\alpha_g h_v)} & \frac{\partial F_{m,n}}{\partial ((1.0 - \alpha_g) h_l) } & \frac{\partial F_{m,n}}{\partial \alpha_e } & \frac{\partial F_{m,n}}{\partial P } \\
\frac{\partial F_{m,l}}{\partial (\alpha_g P_{n})} & \frac{\partial F_{m,l}}{\partial \alpha_g } & \frac{\partial F_{m,l}}{\partial (\alpha_g h_v)} & \frac{\partial F_{m,l}}{\partial ((1.0 - \alpha_g) h_l)} &\frac{\partial F_{m,l}}{\partial \alpha_e } & \frac{\partial F_{m,l}}{\partial P } \\
\frac{\partial F_{e,g}}{\partial (\alpha_g P_{n})} & \frac{\partial F_{e,g}}{\partial \alpha_g } & \frac{\partial F_{e,g}}{\partial (\alpha_g h_v)} & \frac{\partial F_{e,g}}{\partial ((1.0 - \alpha_g) h_l)} &\frac{\partial F_{e,g}}{\partial \alpha_e } & \frac{\partial F_{e,l}}{\partial P } \\
\frac{\partial F_{e,l}}{\partial (\alpha_g P_{n})} & \frac{\partial F_{e,l}}{\partial \alpha_g } & \frac{\partial F_{e,l}}{\partial (\alpha_g h_v)} & \frac{\partial F_{e,l}}{\partial ((1.0 - \alpha_g) h_l)} &\frac{\partial F_{e,l}}{\partial \alpha_e } & \frac{\partial F_{e,g}}{\partial P } \\
\frac{\partial F_{m,e}}{\partial (\alpha_g P_{n})} & \frac{\partial F_{m,e}}{\partial \alpha_g } & \frac{\partial F_{m,e}}{\partial (\alpha_g h_v)} & \frac{\partial F_{m,e}}{\partial ((1.0 - \alpha_g) h_l)} &\frac{\partial F_{m,e}}{\partial \alpha_e } & \frac{\partial F_{m,e}}{\partial P } \\
\frac{\partial F_{m,v}}{\partial (\alpha_g P_{n})} & \frac{\partial F_{m,v}}{\partial \alpha_g } & \frac{\partial F_{m,v}}{\partial (\alpha_g h_v)} & \frac{\partial F_{m,v}}{\partial ((1.0 - \alpha_g) h_l)} & \frac{\partial F_{m,v}}{\partial \alpha_e } & \frac{\partial F_{m,v}}{\partial P }
\end{bmatrix}
\end{equation}
 
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\section{Implementation in \cobra{}}
\label{sec:dd_algo}

The algorithmic implementation of the domain decomposition algorithm is now detailed.
This is going to be long.
Supposedly.

I am a single volume:

\begin{figure}[ht]
\centering
\input{images/isoparametric_volume}
\caption{A single continuity volume.}
\label{fig:single3dvol}
\end{figure}

After the solution in the nonlinear domain has been obtained, a loop over all continuity volumes in the linear domain is performed to obtain the new time values for the continuity volumes.
Each continuity volumes has 

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\subsection{Solver Data Structures}
\label{subsect:domDecompDataStructs}

\cobra{} provides the user with three options for the linear algebra method to be used for solving for the pressure update.
These are the Gauss elimination, the SuperLU solver \cite{Li1999}, and the Pardiso solver \cite{Schenk2006, Schenk2007}.
The SuperLU and the Pardiso solvers utilize sparse matrix storage and the Gauss elimination routine utilizes a full matrix.
The sparsity of the matrices typically encountered are such that use of the direct solver is discouraged.

Based upon the \cobra{} input file, one of these three solvers is used for finding the pressure update.
Given that the original software was written in a mixture FORTRAN 77 and Fortran 90, and as such was based upon procedural programming practices, the memory structure for each of the solvers were predefined in modules.
Depending upon the input the correct array initialization was performed through branching logic in the software.
Additionally, wherever there was interaction with the pressure matrix branching logic was required to properly access the appropriate matrix entries.
This method for having multiple solvers.

\begin{figure}[ht!]
\singlespace\centering
\input{images/matrixClassDiagram}
\caption{Matrix Class Diagram}
\label{fig:matrixClassDiagram}
\end{figure}

This architecture was deemed to be inappropriate for the work being done.
The object-oriented features in Fortran 2003/2008 standards provided an alternative method of handling the pressure matrix.
The matrix storage structure was first replaced with an abstract class, \classname{matrix}.
The \classname{matrix} class contains the number of right hand sides anticipated as well as the total number of pressure updates, $N$.
Additionally, this class would provide interfaces for the following procedures:

\begin{itemize}
\item{put : a procedure that sets $\vec{A}_{i,j}$ to a given value.}
\item{get : a procedure that returns $\vec{A}_{i,j}$.}
\item{scale : a procedure for scaling $\vec{A}_{i, :}$ by a given value.}
\item{reset : a procedure for setting $\vec{A} = \vec{0}$.}
\item{invert : a procedure that returns $\vec{x}$ from $\vec{A}\vec{x} = \vec{b}$.}
\end{itemize}

Given that the SuperLU and the Pardiso solvers utilize sparse matrices and the Gauss elimination routine uses a full matrix, there are two further abstract classes that inherit from \classname{matrix}; they are \classname{fullMatrix} and \classname{sparseMatrix}.
The \classname{fullMatrix} class contains an array representing $\vec{A}$.
The \classname{sparseMatrix} class contains the information required to construct a sparse matrix; however, the exact storage format is not specified in \classname{sparseMatrix}.
Both \classname{fullMatrix} and \classname{sparseMatrix} contain procedural implementations of the interfaces defined in \classname{matrix}.
There are three concrete classes that correspond to the three supported solvers: \classname{dsolveMatrix}, \classname{superluMatrix}, and \classname{pardisoMatrix}; all three implement their own linear system solving routines under the invert interface.
\classname{dsolveMatrix} is a concrete class inheriting from \classname{fullMatrix} that includes pivoting information.
\classname{superluMatrix} and \classname{pardisoMatrix} are concrete classes inheriting from \classname{sparseMatrix} that implement the matrix storage schemes for their respective solvers.
\fig{fig:matrixClassDiagram} shows the class diagram for the \classname{matrix} ecosystem.

\begin{figure}[h!]
\singlespace\centering
\input{images/solverClassDiagram}
\caption{Solver Class Diagram}
\label{fig:solverClassDiagram}
\end{figure}

Once the matrix ecosystem was developed, an abstract solver class was designed.
The \classname{solver} class contains the size of the system, $N_{a}$; a pointer to a \classname{matrix} object, $\vec{A}$; and the right hand side of the linear system, \classname{reS}.
\classname{solver} specifies the interface for an initialization routine, init.
In addition, \classname{solver} specifies the following procedures for manipulating the linear system:

\begin{itemize}
\item{ insert : a procedure for inserting a continuity volume's pressure equation into $\vec{A}_{i, :}$.}
\item{ solve : an interface to call the solver associated with the matrix.}
\item{ scale : a procedure for scaling $\vec{A}_{i, :}$ and $\vec{res}_{i}$.}
\item{ reset : a procedure for setting $\vec{A} = \vec{0}$ and $\vec{res} = \vec{0}$.}
\end{itemize}

There are three concrete classes that inherit from the abstract solver class: \classname{dsolveSolver}, \classname{superluSolver}, and \classname{pardisoSolver}.
Each of these concrete classes specifies an initialization routine that takes an adjacency list data structure, instantiates the \classname{matrix} pointer to the appropriate concrete subtype, and sets the appropriate matrix parameters.
By abstracting the matrices and solvers in this way, a consistent interface is provided to the rest of the software.
\fig{fig:solverClassDiagram} shows the class diagram for the \classname{solver} ecosystem.

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\section{Algorithmic Considerations}
\label{sect:dd_algo_con}

Are there any algorithmic considerations?
I am sure there are.
