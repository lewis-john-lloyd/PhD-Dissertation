\chapter{Nonlinear \cobra{}}
\label{chap:nln_solver}
The original \cobra{} software utilized the single Newton step of the traditional semi-implicit method.
In order to investigate the effects of nonlinear convergence upon the determination of the temporal convergence for a given solution, \cobra{} was modified to enable an iterative global Newton's method.
Several algorithmic problems were identified and resolved during this work.
For effective use of the nonlinear solver, a meaningful convergence metric was required for the determination of nonlinear convergence.
A physics based scaling method was developed to provide a physically meaningful convergence metric.
A metric was developed and tested to aid in the identification of solutions that may not be temporally converged.

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\section{Linear Solution Algorithm}
\label{sect:linCobraAlg}

\cobra{} utilizes the semi-implicit method as outlined in \sect{subsect:semi_implicit}.
A detailed description of the solution algorithm as implemented will be presented in the following section.
The linearized semi-implicit method is not traditionally casts as a system of nonlinear equations.
The governing equations in the traditional semi-implicit method are not viewed through the lens of a single Newton step for a system of nonlinear equations.
Instead, the view that the linearization is from $\vec{x}^{n}$ to $\vec{x}^{n+1}$, as opposed to $\vec{x}^{n+1, k}$ to $\vec{x}^{n+1, k+1}$, is standard in the literature of linearized system analysis software.
For that reason, the following discussion will present the algorithm from the point of view of a single-shot linearization.
The following discussion will parallel the algorithmic flow within the \cobra{} software.

Assuming that all data has been initialized properly, the first step in \cobra{} is a loop over all momentum equations in the domain.
The nonlinear momentum equations, neglecting spatial discretization notation and external sources, are given in \eqref{eqn:si_nln_mom_liq} -- \eqref{eqn:si_nln_mom_ent}.

\begin{IEEEeqnarray}{rCl}
\label{eqn:si_nln_mom_liq}
\dot{m}_{l}^{n+1} - \dot{m}_{l}^{n} & = & \frac{\Delta t}{\Delta x}\left(- \sum_{NK} \left( (\alpha_l \rho_l u_l) u_l \cdot \vec{\bar{A}}\right)^{n}
 -\alpha^{n}_l \nabla P^{n+1} + (\alpha_l \rho_l)^{n} g - K^{n}_{wl}(\dot{m}_l^{n+1})^2 \right. \nonumber \\
 & + & \left. K^{n}_{i,gl}(\dot{m}^{n+1}_l - \dot{m}_g^{n+1})^2 - ((1 - \eta)\Gamma u^{'})^{n} - (S u^{'})^{n}\vphantom{\sum_{NK}}\right) \\
\label{eqn:si_nln_mom_gas}
\dot{m}_{g}^{n+1} - \dot{m}_{g}^{n} & = & \frac{\Delta t}{\Delta x}\left(- \sum_{NK} \left( (\alpha_g \rho_g u_g) u_g  \cdot \vec{\bar{A}}\right)^{n}  -\alpha^{n}_g \nabla P^{n+1} + (\alpha_g \rho_g)^{n} g - K^{n}_{wg}(\dot{m}_g^{n+1})^2 \right.\nonumber \\
& - & \left. K^{n}_{i,gl}(\dot{m}^{n+1}_l - \dot{m}_g^{n+1})^2 -K^{n}_{i,ge}(\dot{m}^{n+1}_e - \dot{m}_g^{n+1})^2 + (\Gamma u^{'})^{n}\vphantom{\sum_{NK}}\right) \\
\label{eqn:si_nln_mom_ent}
\dot{m}_{e}^{n+1} - \dot{m}_{e}^{n} & = & \frac{\Delta t}{\Delta x}\left(- \sum_{NK} \left( (\alpha_e \rho_l u_e) u_e  \cdot \vec{\bar{A}}\right)^n -\alpha^{n}_e \nabla P^{n+1} + (\alpha_e \rho_l)^{n} g - K^{n}_{we}(\dot{m}_e^{n+1})^2\right. \nonumber \\
&+& \left. K^{n}_{i,ge}(\dot{m}^{n+1}_e - \dot{m}_g^{n+1})^2 - (\eta \Gamma u^{'})^{n} + (S u^{'})^n\vphantom{\sum_{NK}}\right)
\end{IEEEeqnarray}

In the above equations the flux terms are summed over $NK$, which indicates the number of continuity volumes to which a given momentum volume connects.
The coefficients $K$ represent effective friction factors calculated using parameters only from time n.
The interfacial transfer terms are also explicitly evaluated.
The momentum equations are then linearized around the current time value, $\dot{\vec{m}}^{n}$, giving \eqref{eqn:si_lin_mom_liq} - \eqref{eqn:si_lin_mom_ent}.

\begin{IEEEeqnarray}{rCl}
\label{eqn:si_lin_mom_liq}
\dot{m}_{l}^{n+1} - \dot{m}_{l}^{n} & = & \frac{\Delta t}{\Delta x}\left(- \sum_{NK} \left( (\alpha_l \rho_l u_l) u_l \cdot \vec{\bar{A}}\right)^{n}
 -\alpha^{n}_l \nabla P^{n} -\alpha^{n}_l \nabla \delta P + (\alpha_l \rho_l)^{n} g - K^{n}_{wl}(\dot{m}_l^{n})^{2} \right. \nonumber \\
  & - & 2 K^{n}_{wl}(\dot{m}_l^{n})(\dot{m}_l^{n+1}-\dot{m}_l^{n})  + K^{n}_{i,gl}(\dot{m}^{n}_l - \dot{m}_g^{n})^2 + 2 K^{n}_{i,gl}(\dot{m}^{n}_l - \dot{m}_g^{n})(\dot{m}^{n}_g - \dot{m}_l^{n}) \nonumber \\
 & + & \left. 2 K^{n}_{i,gl}(\dot{m}^{n}_l - \dot{m}_g^{n})(\dot{m}^{n+1}_l - \dot{m}_g^{n+1}) - ((1 - \eta)\Gamma u^{'})^{n} - (S u^{'})^{n}\vphantom{\sum_{NK}}\right) \\
\label{eqn:si_lin_mom_gas}
\dot{m}_{g}^{n+1} - \dot{m}_{g}^{n} & = & \frac{\Delta t}{\Delta x}\left(- \sum_{NK} \left( (\alpha_g \rho_g u_g) u_g \cdot \vec{\bar{A}}\right)^{n}
 -\alpha^{n}_g \nabla P^{n} -\alpha^{n}_g \nabla \delta P + (\alpha_g \rho_g)^{n} g - K^{n}_{wg}(\dot{m}_g^{n})^{2} \right. \nonumber \\
  & - & 2 K^{n}_{wg}(\dot{m}_g^{n})(\dot{m}_g^{n+1}-\dot{m}_g^{n})  - K^{n}_{i,gl}(\dot{m}^{n}_l - \dot{m}_g^{n})^2 - 2 K^{n}_{i,gl}(\dot{m}^{n}_l - \dot{m}_g^{n})(\dot{m}^{n}_g - \dot{m}_l^{n}) \nonumber \\
 & - & 2 K^{n}_{i,gl}(\dot{m}^{n}_l - \dot{m}_g^{n})(\dot{m}^{n+1}_l - \dot{m}_g^{n+1}) - K^{n}_{i,ge}(\dot{m}^{n}_e - \dot{m}_g^{n})^2 \nonumber \\
 & - & 2 K^{n}_{i,ge}(\dot{m}^{n}_e - \dot{m}_g^{n})(\dot{m}^{n}_g - \dot{m}_e^{n}) - 2 K^{n}_{i,ge}(\dot{m}^{n}_e - \dot{m}_g^{n})(\dot{m}^{n+1}_e - \dot{m}_g^{n+1}) \nonumber \\
 & + & \left.  (\Gamma u^{'})^{n}\vphantom{\sum_{NK}}\right) \\
\label{eqn:si_lin_mom_ent}
\dot{m}_{e}^{n+1} - \dot{m}_{e}^{n} & = & \frac{\Delta t}{\Delta x}\left(- \sum_{NK} \left( (\alpha_e \rho_e u_e) u_e \cdot \vec{\bar{A}}\right)^{n}
 -\alpha^{n}_e \nabla P^{n} - \alpha^{n}_e \nabla \delta P + (\alpha_e \rho_e)^{n} g - K^{n}_{we}(\dot{m}_e^{n})^{2} \right. \nonumber \\
  & - & 2 K^{n}_{we}(\dot{m}_e^{n})(\dot{m}_e^{n+1}-\dot{m}_e^{n})  + K^{n}_{i,ge}(\dot{m}^{n}_e - \dot{m}_g^{n})^2 + 2 K^{n}_{i,ge}(\dot{m}^{n}_e - \dot{m}_g^{n})(\dot{m}^{n}_g - \dot{m}_e^{n}) \nonumber \\
 & + & \left. 2 K^{n}_{i,ge}(\dot{m}^{n}_e - \dot{m}_g^{n})(\dot{m}^{n+1}_e - \dot{m}_g^{n+1}) - (\eta \Gamma u^{'})^{n} + (S u^{'})^{n}\vphantom{\sum_{NK}}\right)
\end{IEEEeqnarray}

The momenta euqations, \eqref{eqn:si_lin_mom_liq} - \eqref{eqn:si_lin_mom_ent}, are now linear in the unknown variables $\dot{\vec{m}}^{n+1}$.
These equations are now solved for the unknown new time momenta, $\dot{\vec{m}}^{n+1}$.
The $\delta P$ is left as an unknown, creating an additional uknown on the right hand side of the linear system.
The resulting system is of the form $\vec{A} \dot{\vec{m}}^{n+1} = \vec{a} + \sum_{NK} \vec{b} \delta P$.
The solution of this linear system is expressed in \eqref{eqn:star:momenta}.

\begin{equation}
\label{eqn:star:momenta}
\dot{\vec{m}}^{n+1} = \vec{A}^{-1} \vec{a} + \sum^{NK}_{i = 1} \vec{A}^{-1} \vec{b} \delta P_{i} = \dot{\vec{m}}^{*} + \sum^{NK}_{i = 1} \frac{\partial \dot{\vec{m}}}{\partial P} \delta P_{i}
\end{equation}

The definition for the new-time momenta is a function of the as of yet unknown changes in pressures that occur in the continuity volumes connected by the momentum volume.
The portion of the right hand side of \eqref{eqn:star:momenta} that is known, $\dot{\vec{m}}^{*}$, is considered to be the tentative new time momenta.
Once all of the momenta equations has been solved in the above manner, providing an estimated new-time momenta for each momentum volume, the domain's continuity volumes are then looped over.
The continuity equations used in this work, omitting external sources, are shown in \eqref{eqn:si_mass_ncg} -- \eqref{eqn:si_nrg_liq}. 
The new time velocities used for advection in the continuity equations is defined with the new time momenta, \eqref{eqn:star:momenta}, in conjunction with \eqref{eqn:si_vel}.

\begin{IEEEeqnarray}{rCl}
\label{eqn:si_mass_ncg}
V_c (\alpha_g \rho_{n})^{n+1} & - & V_c (\alpha_g \rho_{n})^{n} = -\Delta t \sum_{NK}\left( \don{\alpha^{n}_g \rho^{n}_{n}}^{n}_{d} u^{n+1}_g  \cdot \vec{\bar{A}}\right) \\
\label{eqn:si_mass_vap}
V_c \left(\alpha_g \rho_v \right)^{n+1} &-& V_c \left(\alpha_g \rho_v \right)^{n} = - \Delta t \sum_{NK} \left( \don{\alpha^{n}_g \rho^{n}_v}^{n}_{d} u^{n+1}_g  \cdot \vec{\bar{A}}\right) + 
\Delta t \Gamma^{n+1} \\
\label{eqn:si_nrg_gas}
V_c \left( \alpha_g \{\rho_g h_g\} \right)^{n+1} & - & V_c \left( \alpha_g \{\rho_g h_g\} \right)^{n}  = -\Delta t \sum_{NK} \left(  \don{\alpha^{n}_g \{\rho_g h_g\}^{n}}^{n}_{d} u^{n+1}_g  \cdot \vec{\bar{A}}\right) \nonumber \\
&+& \Delta t \left[\Gamma h^{'}_v + q_{i,v} + q_{gl} + q_{wg} \right]^{n+1} + V_c \alpha^{n}_g ( P^{n+1} - P^{n} ) \\
\label{eqn:si_nrg_liq}
V_c\left( \alpha_l \rho_l h_l \right)^{n+1} & - & V_c\left( \alpha_l \rho_l h_l \right)^{n} = \Delta t \left[q_{wl} -\Gamma h^{'}_l +  q_{i,l} - q_{gl}\right]^{n+1} + V_c \alpha^{n}_l (P^{\,n+1} - P^{\,n})   \nonumber \\
& -& \Delta t \sum_{NK} \left( \don{\alpha^{n}_l \rho^{n}_l h^{n}_l}^{n}_{d} u^{n+1}_l \cdot \vec{\bar{A}} + \don{\alpha^{n}_e \rho^{n}_l h^{n}_l}^{n}_{d} u^{n+1}_e  \cdot \vec{\bar{A}}\right) \\
\label{eqn:si_mass_ent}
V_c \left(\alpha_e \rho_l \right)^{n+1} & - & V_c \left(\alpha_e \rho_l \right)^{n} = -\Delta t \sum_{NK}\left( \don{\alpha^{n}_e \rho^{n}_l}^{n}_{d} u^{n+1}_e  \cdot \vec{\bar{A}}\right)\nonumber \\ 
&+& \Delta t\left[ S -\eta\Gamma \right]^{n+1} \\
\label{eqn:si_mass_liq}
V_c \left(\alpha_l \rho_l \right)^{n+1} & - & V_c \left(\alpha_l \rho_l \right)^{n} =  -\Delta t \sum_{NK}\left( \don{\alpha^n_l \rho^n_l}^{n}_{d} u^{n+1}_l  \cdot \vec{\bar{A}}\right) \nonumber \\
&- &\Delta t\left[(1-\eta)\Gamma + S \right]^{n+1}
\end{IEEEeqnarray}

Unlike the momentum equations, the continuity equations are linearized with variables other their conserved quantities, \eqref{eqn:independentVariables}.
This creates a more complicated linearization procedure than that used for the momenta equations.
The newtime variables in \eqref{eqn:si_mass_ncg} -- \eqref{eqn:si_nrg_liq}  are linearized about the oldtime variables with respect to the continuity variables in \eqref{eqn:independentVariables}.
The use of the \eqref{eqn:star:momenta} in defining the new-time velocities introduces inter-continuity volume coupling through the momentum equations dependency upon changes in pressure, $\delta P$.
With the addition of the unknown pressure updates via the momenta, the six linearized continuity equations now form a [ 6 x 6 + NK ] linear system.
\comment{I need to straighten out the nomenclature for connections. NK has previously been used to indicate the number of volumes to which a flowpath is connected. That doesn't make sense though since each flowpath can connect to only two volumes. Anyways... That needs to be fixed.}
Additionally, while the momentum equations were fully expanded to solve for the new-time conserved quantities directly, the continuity equations instead solve for their associated updates, \eqref{eqn:linearUpdate}.

\begin{equation}
\label{eqn:linearUpdate}
\begin{bmatrix}
\delta ( \alpha_{g} P_{n} ) \\
\delta \alpha_{g} \\
\delta ( \alpha_{g} h_v ) \\
\delta ( (1 - \alpha_{g} ) h_l ) \\
\delta \alpha_e \\
\delta P 
\end{bmatrix}
=
\begin{bmatrix}
( \alpha_{g} P_{n})^{n+1} - (\alpha_{g} P_{g} )^{n} \\
\alpha^{n+1}_{g} - \alpha^{n}_{g} \\
( \alpha_{g} h_{v} )^{n+1} - ( \alpha_{g} h_{v} )^{n} \\
( ( 1 - \alpha_{g} ) h_{l} )^{n+1} - ( ( 1 - \alpha_{g} ) h_{l} )^{n} \\
\alpha^{n+1}_{e} - \alpha^{n}_{e} \\
 P^{n+1} - P^{n}
\end{bmatrix}
\end{equation}

Each continuity volume's linearized system of equations is subjected to an LU decomposition without pivoting, leaving an upper triangular matrix for each continuity volume.
Since the pressure update corresponds to the last row in the system of equations, this allows for the isolation of the pressure updates.
The last row of each continuity volume's linear system are then formed into a global pressure matrix.
This will be a [ N x N ] system, where N is the number of continuity volumes in the domain.
\comment{Once again, I need to get some basic nomenclature nailed down.}
This matrix is then solved to determine the pressure updates for the whole domain.
Each continuity volume is then traversed so that the pressure update can be used in solving its associated upper triangular system for the updates to the other five continuity variables in \eqref{eqn:linearUpdate}.
Once all the continuity volumes are updated, \eqref{eqn:star:momenta} is then utilized, along with the now known pressure updates, to obtain the new-time momenta in each flowpath.
Upon completion of this process, a single timestep is considered to have been taken.

\comment{Add an algorithm here?}

The solution obtained via this process is subjected to several physical and computational limits discussed in \eqref{sect:algoConcerns}.

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\section{Nonlinear Solution Algorithm}
\label{sect:nlnCobraAlg}
As obtained, the \cobra{} software used the single Newton step of the semi-implicit method as outlined in \sect{sect:linCobraAlg} for a timestep.
In order to evaluate the subdomain nonlinear refinement algorithm, \cobra{} needed to be modified to be able to take multiple Newton steps within a given step.
Additionally, a linesearch globalization strategy was added to the software.
As such, the \cobra{} software needed to be modified to be able do the following:

\begin{itemize}
\item{Create a data framework for constructing vector quantities such as $\vec{x}^{k}$ and $\vec{F}$.}
\item{Correctly evaluate $\vec{F}(\vec{x}^{k})$ and $\vec{J}(x^{k})$.}
\item{Develop proper scaling of $\vec{F}(\vec{x}^{k})$.}
\item{Implement a globalization strategy for Newton's method.}
\end{itemize}

Given the formation of the governing equations from \sect{sect:linCobraAlg}, several modification were required to implement a nonlinear solver.
The correct linearization about a new-time guess value as opposed to the old time.
Each Newton step is an incremental change in the new-time variable, not a change in the independent parameters over at timestep.
This required that each of the Fortran procedures involved with the calculation of the various physical parameters and operators needed to be evaluated to determine if the variables being used were correct.

In \cobra{} the smallest geometric component that can be input is the channel.
As mentioned in \ref{sect:geometry} the channels inherit their geometric properties from the section in which they reside.
To create geometrically complicated problems, it is possible to enforce zero momentum in a given momentum volume.
This constraint is known as a no-flow boundary condition.
These boundary conditions decoupled adjacent continuity volumes by eliminating the flow-paths that connect them.
This boundary condition allows designers to create more complicated models by isolating portions of the domain.
These areas of the domain do not impact the actual solution in the portion of the domain that has boundary values.
After evaluating several prototypical models, it was determined that a large portion of the domain of these problems were thermodynamically isolable.
During development of the infrastructure to create the vectorized residuals, scale factors, and updates, it was determined that those volumes which were thermodynamically isolated would not be included in the simulated domain.

\comment{A picture of the active vs. inactive would be nice.}

Originally, \cobra{} would solve the momentum and continuity equations at every defined location in the problem.
To determine which areas of the domain were active and which ones were inactive, a geometry traversing routine was written.
This routine parsed the input file and proceeded to create an adjacency list data structure to represent the active portion of the domain.
This data structure allowed the active volumes to be treated independently from the memory structure of the software.

\comment{How much detail should I add regarding the active vs inactive?}

\cobra{} was originally written from a procedural programming point of view.
The [ N x N ] pressure matrix was sized based upon the number of volumes in the domain, not the number of active volumes.
There was a precise ordering of l

Once the active volumes were identified, the way in which the solver was stored in memory was changed.
Previously, there had been a hard coded solver.
Now the solvers are objects.
These objects are awesome.
I made them.
The data structures involves matrices.
There are two types of matrix data structures: sparse and full.
Each solver has a matrix.
The matrix is sized based upon the active domain.

\comment{Diagram of the object relationship?}

\comment{Discussion of input?}
The nonlinear solver has a $F_{tol}$, a $d_{tol}$, and a $k_{max}$.

\comment{Linesearch algorithm?}
There is a quadratic backtracking linesearch algorithm, but it is not used for this work.
It was turned off because there had not been enough testing for robustness.

\comment{Here an algorithm for the nonlinear solver would be nice.}

The nonlinear solver had to add the ability to undo a trip through the momentum and continuity loops.

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\section{Algorithmic Considerations}
\label{sect:algoConcerns}

As part of the \cobra{} modification a novel operator based scaling has been developed to obtain meaningful convergence thresholds.

The methods outlined in \sect{sect:solution_techniques} have several algorithmic issues that need to be addressed.
Among these issues are phase appearance and disappearance (hereafter referred to as phase transition), timestep solution acceptance criteria, and timestep size selection.

Given that the governing conservation laws in thermal-hydraulic analyses are those of two-phase flow, phase transition is integral to accurate simulations.
The methods for addressing phase transitions within two-phase analysis software are ad hoc procedures that vary from software to software.
While each algorithmic implementation of the various methods addresses this issue out of necessity, there is no systematic or optimal way of doing so.
However, certain physical limits have been identified that need to be considered \cite{Bestion2000}.

When the two-phase flow within \cobra{} approaches that of single-phase flow, there is a lower limit imposed upon the volume fraction of the phase that is disappearing.
This means that \cobra{} does not transition between the two-phase flow governing equations and the governing equations for single-phase flow.
Even during simulated single-phase flow, the non-dominant phase is still present, but it is at a very small volume fraction.
However, since the \ncgs{} and the vapor fields share a common volume fraction, the partial pressure of the \ncgs{} is allowed to go to zero. 
Since \cobra{} incorporates two liquid fields, the lower limit for the aggregate liquid volume fraction, $\alpha_e + \alpha_l$, is equally divided between the two liquid fields.
As a phase approaches depletion, $\alpha_k \rightarrow \alpha_{k,\text{min}}$, the velocity of the depleting phase is required to approach that of the remaining phase.
This velocity equilibrium is imposed by artificially increasing the interfacial drag between the two phases.

However, there is a subtle issue created by artificially increasing the interfacial drag between the two phases.
The increased interfacial drag will dominate the residual for the momentum equation of the phase that is not disappearing.
It was determined that the two coefficients should be kept the same.
Since the new-time velocity is what is forced to be equal by the interfacial drag, at the beginning of the next timestep, the old time velocity is not equal to the new-time velocity at the end of the previous timestep.
This meant that at the beginning of every timestep where the simulation was effectively single phase, there was slip between the two phases even though there was no slip at the end of the previous timestep.
To assist in removing this problem, the velocity of the depleted phase is relinearized every timestep to be equal to within round off of the dominant phase.
The linearization point is determined by the ratio of the macroscopic densities.
 
Upon completion of a timestep within \cobra{}, there are certain constraints that are imposed upon the independent parameters.
These constraints are designed to deal with the possibility that the obtained solution may not be an accurate one.
After the single Newton step, the updated parameters are evaluated to determine their validity.
There are two ways of resolving potentially invalid solutions: parameter limiting and timestep failure.
The limiting procedure can either truncate the updated parameter so that it falls within a valid range, or the timestep can be considered a failure.
When a predicted volume fraction falls outside of its valid range, it is truncated to obey the constraint of equation \eqref{eqn:volume_fraction}.

\begin{equation}
\label{eqn:volume_fraction}
\alpha_{k,\text{min}} \leq \alpha_k \leq \alpha_{k,\text{max}} 
\end{equation}

There are also limits placed upon the changes of the thermodynamic parameters within a timestep in \cobra{}.
The constrained thermodynamic parameters and the limits imposed upon their per-timestep changes are listed below.

\begin{itemize}
\item{Change of phasic enthalpy cannot be greater than 45 [$\frac{\text{BTU}}{\lbm{}}$].}
\item{Change in pressure cannot be greater than 20 [psia].}
\item{Change in partial pressure of the \ncg{} field cannot be greater than 20 [psia].}
\item{Thermodynamic variables would fall outside of the range of validity of the equations of state.}
\end{itemize}

The first three limits are an attempt to mitigate an initial guess that may be outside of the Newton step's radius of convergence.
If any of the above limits are exceeded, the timestep is considered a failure and is repeated with a smaller timestep size.

Another algorithmic concern is how to identify a potentially poor linearization point in the presence of phase transitions. 
This can be considered a predictive error correction technique.
It uses information from the explicit portion of the nonlinear residual to identify situations where the linearization point may be poor.
In \cobra{} this method is used only for the prediction of \ncg{} appearance.

To determine the \dt{} at each timestep \cobra{} uses an adaptive timestep selection algorithm.
This algorithm is based upon a maximum permissible timestep based upon the material Courant limit.
The \dt{} for any timestep is given by \eqref{eqn:time_step}.

\begin{equation}
\label{eqn:time_step}
\Delta t^{n \rightarrow n+1} = \max\left[ \Delta t_{\text{MIN}}, \min\left[1.2 \Delta t^{n-1 \rightarrow n}, 0.85 \Delta t_{\text{CRNT}}, \Delta t_{\text{MAX}} \right]\right]
\end{equation}

$\Delta t_{\text{CRNT}}$ is the most restrictive Courant number calculated for both axial and transverse flow, and a \dt{} that is based upon the time calculated to empty a given volume of the mass of a given field.
The most restrictive of the Courant timestep is used as $\Delta t^{n \rightarrow n+1}$.

\cobra{} utilized a single-shot linearization for its solution technique.
As a result of that design decision, memory saving techniques were employed in the construction of the software that precluded more than one Newton step.
In particular, there was the implicit assumption within the software that the first Newton iterate, $\vec{x}^{n+1, 0}$, was the old-time variable $\vec{x}^{n}$.
This design decision required the vetting of all subroutines involved with the evaluation of the components of both the nonlinear residual and its Jacobian.
In addition, the assumption that $\vec{x}^{n+1, k} = \vec{x}^{n}$ produced source code that was inconsistent with an iterative Newton method.
The source code was modified to reflect the intended discretization of the governing conservation laws.
To do this, areas had to be identified where: there were implicit cancellation of terms, the new-time variables were used in place of old-time variables, and the old-time variables were used in place of new-time variables.
Where appropriate, the software was changed to reflect the distinction between old-time and iterate variables and to introduce terms that had been assumed to be equal to zero.

Once the appropriate variables were used for the evaluation of the nonlinear residuals and the Jacobian, a Newton loop was introduced to allow multiple Newton steps.
\alg{alg:nl_cobra} contains the current algorithmic implementation of the nonlinear semi-implicit method.

\begin{algo}[H]
\setlength{\baselineskip}{0.625\baselineskip}
\begin{algorithmic}[1]
\Require $\vec{x}^{0}$ and $t^{0}$
\Set $n = 0$
\Loop \; Transient Loop
    \State $t^{n+1} : = t^{n} + \Delta t$
    \State $k = 0$
    \Define $\vec{x}^{n+1,0}$
	\Calculate $\vec{F}(\vec{x}^{n+1,0})$ and $\vec{J}(\vec{x}^{n+1,0})$
    \Loop \; Newton Loop
		\Calculate $\vec{\delta x} = - \vec{J}^{-1}\cdot\vec{F}$
		$j = 0$		
		\Calculate $\vec{x}^{n+1,k+1,j}$
		\Calculate $\vec{F}(\vec{x}^{n+1,k+1,j})$
		\Loop \; Globalization Loop
			\If{ Globalization loop termination criteria not met}
				\Calculate $\lambda_j$
				\Calculate $\vec{x}^{n+1,k+1,j+1} = \vec{x}^{n+1,k} + \lambda \vec{\delta x}$
				\Calculate $\vec{F}(\vec{x}^{n+1,k+1,j+1})$
				\State $j = j + 1$			
			\Else
				\Calculate $\vec{J}(\vec{x}^{n+1,k+1,j})$
				\Exit Globalization Loop
			\EndIf
		\EndLoop			
		\If{ Newton loop termination criteria met}
			\Exit Newton Loop
		\EndIf
	\EndLoop
	\State $n = n + 1$
\EndLoop
\end{algorithmic}
\caption{Nonlinear \cobra{} algorithm.}
\label{alg:nl_cobra}
\end{algo}

In \alg{alg:nl_cobra}, there are three steps that require discussion.
First is the Newton Loop termination criteria.
There are three Newton loop termination mechanisms, listed below.

\begin{enumerate}
\item{$k > k_{\,\text{MAX}}$}
\item{$||(\vec{S}^{k+1})^{-1}\vec{F}^{k+1}||_{\infty} \leq F_{\text{ABS}}$}
\item{$||(\vec{D}^{k+1})^{-1}\vec{\delta x}^{k}||_{\infty} \leq \delta_{\text{ABS}}$}
\end{enumerate}

Current values for $k_{\,\text{MAX}}$, $F_{\text{ABS}}$ and $\delta_{\text{ABS}}$ are $35$, $1.0$E$-05$, and $1.0$E$-10$, respectively.
The scaling vectors, $\vec{S}$ and $\vec{D}$, will be addressed later.

The second is the globalization loop termination criteria.
The globalization strategy implemented in \cobra{} is a line search algorithm \cite{Dennis1996}.
The two globalization loop termination criteria are:

\begin{enumerate}
\item{$\frac{1}{2}||\vec{F}^{k+1, j}||^{2}_{2} < \frac{1}{2}||\vec{F}^{k}||^{2}_{2} - \alpha ||\vec{F}^{k}||^{2}_{2}$ }
\item{$||\lambda_{j+1} \vec{\delta x}^{k}||_{\infty} < \delta_{\text{abs}}$}
\end{enumerate}

The third point requiring discussion is the calculation of the Newton update vector.
If neither of the loop termination criteria are met, then a step-length parameter, $\lambda_j$, is calculated.
On the first pass through the globalization loop within a given Newton step, a quadratic backtracking model is adopted.
On subsequent passes, a cubic-backtracking model is used.
 
Since vector forms of the nonlinear residual and the independent parameters are used in determining nonlinear convergence and in the globalization algorithm, they needed to be easily manipulated.
A subroutine was written to gather the discrete variables of the independent parameters into a single vector.
Additional source code modifications were necessary to construct and gather the components of the nonlinear residual.

The development of the nonlinear solver within \cobra{} took place under strict quality assurance guidelines.
At every step of the development, the linear solver was required to maintain the same solution.
This verification was dependent upon a larger number of verification and assessment problems.
The output of the unmodified \cobra{} and the modified \cobra{} software was compared to machine precision.
It was required that either the results of the two simulations be identical or that the reason for the difference be identified and understood.
The \cobra{} software has the ability to repeat a time-step.
As such, it was required that the backup capabilities continued to work while nonlinear solver was being implemented.
Additionally, testing was done to ensure that the ability to restart the software mid-simulation was unaffected.
While adding time to the development cycle, the overhead of the quality assurance procedures ensured that the linear solver could continue to be used for design purposes.

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\section{Operator-Based Scaling}
\label{sect:nln_scaling}
An important aspect of the nonlinear solver outlined above is the convergence criteria.
The iterative solver depends upon the scaled residual to determine when convergence has been achieved.
In particular, various norms of the residual are evaluated to measure the degree to which the nonlinear system of algebraic equations are being satisfied.
The evaluation of residual norms encourages the use of a scaling matrix for the residual vector.
Without scaling the residual has several negative characteristics.
The different equations will have different scales at a given point in time because of the physical quantities that they represent.
Over the course of the transient the magnitude of any given equation can vary dramatically.
Summing equations with different units is not good.
When the summation occurs those equations whose terms are the largest may have an unscaled residual that is orders of magnitude greater than others.
This will mean that any norm taken of the residuals will be subject to a bias towards those equations with the largest numerical value by virtue of their units.

Here is a list of the residuals and their units.
For a given continuity volume, the nonlinear residual will have six components: four for the conservation of mass and two for the conservation of energy.
For each momentum volume, the three conservation of momentum equations will form the three components of the nonlinear residual.
These residuals have the units of the conserved quantities for their corresponding PDEs; \tab{tab:scaling_units_scales} shows the units for the different conservation equations.

\begin{table}[ht]
\centering
\input{tables/residuals_and_units}
\caption{Residuals and their units.}
\label{tab:scaling_units_scales}
\end{table}

For the aforementioned reasons, it is desirable to scale the residuals.
A challenge that has been addressed in this work is the development of a method for scaling of these residuals that is based upon the local physics of interest at any given point in the transient.
In constructing this scaling factor it was determined that the following characteristics were desirable:

\begin{itemize}
\item{$(S_{i}^{k})^{-1} F^{k}_i \approx 1$ when $\vec{x}^{k}$ is a "poor" solution.}
\item{$(S_{i}^{k})^{-1} F^{k}_i \rightarrow 0$ when phase $i$ disappears.}
\item{$0 \leq \abs{(S_{i}^{k})^{-1} F^{k}_{i}} \leq 1 $ for all values of $\vec{x}^{k}_i$.}
\end{itemize}

This dynamic behavior of the residual necessitates a method for scaling that adapts to relevant physical situations.
The scaling method developed during this work is an operator-based approach.
The governing PDEs can be viewed as a collection of operators, both linear and nonlinear, acting upon the vector of independent parameters.
The summation of these operators must balance to zero for the nonlinear equation to be satisfied.
The scaling factor developed uses the magnitudes of these operators to determine an absolute measure of the physics processes occurring in a given volume.
This is accomplished by summing the absolute value of the different discrete operators in the governing equations. 

To illustrate this scaling procedure, consider the discrete conservation of continuous liquid mass \eqref{eqn:si_mass_liq}.
The residual for \eqref{eqn:si_mass_liq} is given by \eqref{eqn:res_mass_liq}.

\begin{equation}
\label{eqn:res_mass_liq}
F_{m,l} = \Delta t \left[ V_c \frac{\left(\alpha_l \rho_l \right)^{n+1} - \left(\alpha_l \rho_l \right)^{n}}{\Delta t} + \sum_{NK}\left( \don{\alpha^n_l \rho^n_l}^{n}_{d} u^{n+1}_l  \cdot \vec{\bar{A}}\right) + \left[(1-\eta)\Gamma + S \right]^{n+1}\right]
\end{equation}

In this equation there are five physically meaningful quantities: the temporal difference, the mass flowing into the volume, the mass flowing out of the volume, the mass exchange with the gaseous phase, and the mass exchange with the entrained liquid field.

The scaling chosen for this residual is shown by \eqref{eqn:scaling_factor}.
\begin{equation}
\label{eqn:scaling_factor}
S_{m,l} = \Delta t \left[ V_c \abs{\frac{\left(\alpha_l \rho_l \right)^{n+1} - \left(\alpha_l \rho_l \right)^{n}}{\Delta t}} + \sum_{NK}\abs{\left( \don{\alpha^n_l \rho^n_l}^{n}_{d} u^{n+1}_l  \cdot \vec{\bar{A}}\right)} + \left[\abs{(1-\eta)\Gamma} + \abs{S} \right]^{n+1}\right]
\end{equation}

This scaling creates a relative measure of the nonlinear residual when compared to the magnitude of the physics involved in the process.
The other mass, energy, and momentum equations each have similarly defined scaling factors for their respective residuals.
For convergence testing in the nonlinear version of \cobra{} and residual evaluation during the linear mode, the scaled nonlinear residual is used.

The issue of phase transition also needed to be considered during this work.
Since \cobra{} does not actually transition the governing equations to those for single-phase flow, there will always be a nonlinear residual for those phases that are approximately absent.
It was determined that the effects of maintaining a depleted phase in the system of equations when solving the nonlinear problem created unique issues.
The unscaled residuals would be on the order of machine round-off.
The operator based scaling factors for these residuals would also be within orders of magnitude of machine round-off.
This created the situation where the scaled nonlinear residual for the depleted field would be of $\mathcal{O}$(1).
These depleted residuals would dominate the norms used to determine convergence.
To overcome this deficiency it was determined that when a phase or field began to deplete, the scaling factor would be scaled up to create an artificial decrease in the residual to counter the artificial presence of the depleted field.
This scaling is shown by \eqref{eqn:scaling_factor_small}.

\begin{equation}
\label{eqn:scaling_factor_small}
S_k = \max[1.0, \left(C_1 \frac{\alpha_{k,\text{MIN}}}{\alpha_k}\right)^{C_2} ] S_k
\end{equation}

For this work, the constant $C_1$ was set equal to 100, and the exponent $C_2$ was set equal to 10.
This particular phase transition scaling produced the regular operator scaling factor when the volume fraction of a phase is at least two orders of magnitude greater than the minimum volume fraction for that phase.
This drove the scaled residuals for phases that were nominally not present to well below those residuals for equations that were active.

Another phase depletion limit was floor placed upon the scale factor.
For each equation, the scale factor was limited to the minimum possible value of the conserved quantity based upon the volume fraction limits.
For the mass equations it would be the minimum macroscopic density of the given field based upon the minimum volume fraction for that field.


\begin{table}[ht]
\centering
\input{tables/minimum_conserved_values}
\caption{Minimum conserved quantities for conservation equations.}
\label{tab:minimumConservedValues}
\end{table}

\tab{tab:minimumConservedValues} shows the floors for the various residuals.
These floors are based update during the iterative process.

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\section{Convergence Metric}
\label{sect:temporal_convergence}

An important factor in thermal-hydraulic safety analysis is the temporal convergence of the solution.
A definition for a temporally converged solution is required.
In theory, a temporally converged solution is one where the local truncation error due to the discrete approximation of the temporal integral is orders of magnitude below both the engineering scales of interest and precision of the physical models being used in the simulation.
Unfortunately, the precise measurement of the error in a simulation requires that an analytic solution be available for comparison.
During the simulation of physically realistic systems, there is rarely an analytic solution against which to compare.
This situation requires a slightly different definition of a temporally converged solution --- a definition that does not depend upon accurately measuring the local truncation error.

An alternative definition for temporal convergence could be ``as the timestep size is reduced, the change in the solution is small enough."
While commonly used, this definition is subjective.
Traditionally, ``change in solution" is addressed in a very qualitative manner.
Engineering judgment of which parameters of the solution are of interest is required.
These parameters may include items of regulatory concern such as peak clad temperature or peak system pressure.
Examining only engineering parameters of interest is a weakness.
This locality means that the entire solution domain is not being considered.
Depending upon the context in which the work is being done, the degree of ``small enough" may be nothing more than looking at a graph of the parameter of interest and using engineering judgment to say that ``those two graphs look about the same."
In some cases, a more quantifiable measure may be used.
An example of a quantifiable metric would be if two simulations with different \dtmax{} are classified as dissimilar if the two solutions produce a ``calculated peak fuel cladding temperature different by more than $50\,^{\circ}\mathrm{F}$" \cite{CFR10}.

While it may be that the change in the chosen parameters of interest does not exceed the limits placed upon it as the timestep size is refined, that behavior does not imply that the solution obtained is the solution to the discrete nonlinear problem.
A metric that can quantify the degree to which the obtained solution satisfies the nonlinear system of equations would be of great value.
The previously mentioned work into nonlinear convergence shows that a solution may be timestep size insensitive but not be the converged solution of the discretized problem \cite{Knoll2001}.
If the nonlinearities of the discrete governing equations are not resolved, then the temporal convergence rate can be degraded.
This degradation can produce results that qualitatively appear to be converged due to an almost zeroth order of temporal accuracy.
In practice, the timestep size insensitivity of a solution is often interpreted as temporal convergence.
This apparent temporal convergence, or timestep size insensitivity, of the solution may not be a result of reaching the solution to the discretized nonlinear equations, but instead could be indicative of the degraded order of accuracy due to the failure to resolve the nonlinearities at each timestep.
To determine if the timestep size insensitive transient solution is both timestep size insensitive and an accurate solution to the nonlinear problem, it is necessary to examine the nonlinear convergence of the system as an issue separate from the temporal-convergence.

The norm of the scaled residual from \sect{sect:nln_scaling} provides a well-scaled metric for instantaneous nonlinear convergence at any given time in the simulation.
The residual vector norm is divided by the number of equations in the residual to provide an average residual value per equation.
This equation-averaged scaled residual provides a metric for determining the degree of nonlinear convergence at any timestep in the simulation.
The natural extension of this metric to transient problems would be a temporal integral, \eqref{eqn:trans_res_simple}, of said norm.

\begin{equation}
\label{eqn:trans_res_simple}
R = \int_{t^{0}}^{t^{N}} ||\vec{F}(\tau)||_2 \,\mathrm{d} \tau
\end{equation}

Given the bounds of the scaled residual it was considered desirable to have a similarly scaled transient residual.
The transient residual in \eqref{eqn:trans_res_simple} possesses a dependence upon the number of timesteps taken.
To remove this dependence, a temporal average was instead investigated, \eqref{eqn:trans_res_ave}.

\begin{equation}
\label{eqn:trans_res_ave}
\tilde{R} = \frac{\int_{t^{0}}^{t^{N}} ||\vec{F}(\tau)||_2 \,\mathrm{d} \tau}{t^{N} - t^{0}}
\end{equation}

This metric possesses the desirable bounds $0 \leq R \leq 1$.
Other weighted temporal integrals were considered, such as a simple moment about $t^{0}$, \eqref{eqn:trans_res_mom}.
However, this moment has the disadvantage of weighting the latter portion of the transient greater than the early portion.

\begin{equation}
\label{eqn:trans_res_mom}
\tilde{R}_{\text{M}} = \frac{\int_{t^{0}}^{t^{N}} \,\tau\,||\vec{F}(\tau)||_2 \,\mathrm{d} \tau}{\int_{t^{0}}^{t^{N}} \,\tau \,\mathrm{d} \tau}
\end{equation}