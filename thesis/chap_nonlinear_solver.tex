\chapter{Nonlinear \cobra{}}
\label{chap:nln_solver}
The original \cobra{} software utilized the single Newton step of the traditional semi-implicit method.
In order to investigate the effects of nonlinear convergence upon the determination of the temporal convergence for a given solution, \cobra{} was modified to enable an iterative global Newton's method.
Several algorithmic problems were identified and resolved during this work.
For effective use of the nonlinear solver, a meaningful convergence metric was required for the determination of nonlinear convergence.
A physics based scaling method was developed to provide a physically meaningful convergence metric.
A metric was developed and tested to aid in the identification of solutions that may not be temporally converged.

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\section{Linear Solver}
\label{sect:linCobraAlg}

\cobra{} utilizes the semi-implicit method as outlined in \sect{subsect:semi_implicit}.
A detailed description of the solution algorithm as implemented will be presented in the following section.
The linearized semi-implicit method is not traditionally casts as a system of nonlinear equations.
The governing equations in the traditional semi-implicit method are not viewed through the lens of a single Newton step for a system of nonlinear equations.
Instead, the view that the linearization is from $\vec{x}^{n}$ to $\vec{x}^{n+1}$, as opposed to $\vec{x}^{n+1, k}$ to $\vec{x}^{n+1, k+1}$, is standard in the literature of linearized system analysis software.
For that reason, the following discussion will present the algorithm from the point of view of a single-shot linearization.
The following discussion will parallel the algorithmic flow within the \cobra{} software.

Assuming that all data has been initialized properly, the first step in \cobra{} is a loop over all momentum equations in the domain.
The nonlinear momentum equations, neglecting spatial discretization notation and external sources, are given in \eqref{eqn:nlnLiqMomentumEquation} -- \eqref{eqn:nlnEntMomentumEquation}.

\begin{IEEEeqnarray}{rCl}
\label{eqn:nlnLiqMomentumEquation}
\dot{m}_{l}^{n+1} - \dot{m}_{l}^{n} & = & \frac{\dt{}}{\dx{}}\left(- \sum^{N_{c}}_{i\,=\,1} \left( (\alpha_l \rho_l u_l) u_l \cdot \vec{\bar{A}}\right)_{i}^{n}
 - \ave{\alpha_{l}}_{a}^{n} \nabla P^{\,n+1} + g \ave{\alpha_l \rho_l}_{a}^{n} - K^{n}_{wl}(\dot{m}_l^{n+1})^2 \right. \nonumber \\
 & + & \left. K^{n}_{i,gl}(\dot{m}^{n+1}_l - \dot{m}_g^{n+1})^2 - \left[(1 - \eta)\Gamma u^{'} + S u^{'}\right]^{n}\vphantom{\sum_{N_{k}}}\right) \\
\label{eqn:nlnGasMomentumEquation}
\dot{m}_{g}^{n+1} - \dot{m}_{g}^{n} & = & \frac{\dt{}}{\dx{}}\left(- \sum^{N_{c}}_{i\,=\,1} \left( (\alpha_g \rho_g u_g) u_g  \cdot \vec{\bar{A}}\right)_{i}^{n} - \ave{\alpha_{g}}_{a}^{n} \nabla P^{\,n + 1} + g \ave{\alpha_g \rho_g}_{a}^{n} - K^{n}_{wg}(\dot{m}_g^{n+1})^2 \right.\nonumber \\
& - & \left. K^{n}_{i,gl}(\dot{m}^{n+1}_l - \dot{m}_g^{n+1})^2 -K^{n}_{i,ge}(\dot{m}^{n+1}_e - \dot{m}_g^{n+1})^2 + \left[\Gamma u^{'}\right]^{n}\vphantom{\sum_{N_{k}}}\right) \\
\label{eqn:nlnEntMomentumEquation}
\dot{m}_{e}^{n+1} - \dot{m}_{e}^{n} & = & \frac{\dt{}}{\dx{}}\left(- \sum^{N_{c}}_{i\,=\,1} \left( (\alpha_e \rho_l u_e) u_e  \cdot \vec{\bar{A}}\right)_{i}^n -\ave{\alpha_{e}}_{a}^{n} \nabla P^{\,n+1} + g \ave{\alpha_e \rho_l}_{a}^{n} - K^{n}_{we}(\dot{m}_e^{n+1})^2\right. \nonumber \\
&+& \left. K^{n}_{i,ge}(\dot{m}^{n+1}_e - \dot{m}_g^{n+1})^2 - \left[ \eta \Gamma u^{'} - S u^{'}\right]^{n}\vphantom{\sum_{N_{k}}}\right)
\end{IEEEeqnarray}

In the above equations the flux terms are summed over $N_{f}$, which indicates the number of continuity volumes to which a given momentum volume connects.
The coefficients $K$ represent effective friction factors calculated using parameters only from time n.
The interfacial transfer terms are also explicitly evaluated.
The momentum equations are then linearized around the current time value, $\dot{\vec{m}}^{n}$, giving \eqref{eqn:linLiqMomentumEquation} - \eqref{eqn:linEntMomentumEquation}.

\begin{IEEEeqnarray}{rCl}
\label{eqn:linLiqMomentumEquation}
\dot{m}_{l}^{n+1} - \dot{m}_{l}^{n} & = & \frac{\dt{}}{\dx{}}\left(- \sum^{N_{c}}_{i\,=\,1} \left( (\alpha_l \rho_l u_l) u_l \cdot \vec{\bar{A}}\right)_{i}^{n}
 -\ave{\alpha_{l}}_{a}^{n} \nabla P^{\,n} -\ave{\alpha_{l}}_{a}^{n} \nabla \delta P + g \ave{\alpha_l \rho_l}_{a}^{n} \right. \nonumber \\
  & + & K^{n}_{wl}(\dot{m}_l^{n})^{2} - 2 K^{n}_{wl}\dot{m}_l^{n}\dot{m}_l^{n+1} - K^{n}_{i,gl}(\dot{m}^{n}_l - \dot{m}_g^{n})^2  \nonumber \\
 & + & \left. 2 K^{n}_{i,gl}(\dot{m}^{n}_l - \dot{m}_g^{n})(\dot{m}^{n+1}_l - \dot{m}_g^{n+1}) - \left[(1 - \eta)\Gamma u^{'} + S u^{'}\right]^{n}\vphantom{\sum_{N_{k}}}\right) \\
\label{eqn:linGasMomentumEquation}
\dot{m}_{g}^{n+1} - \dot{m}_{g}^{n} & = & \frac{\dt{}}{\dx{}}\left(- \sum^{N_{c}}_{i\,=\,1} \left( (\alpha_g \rho_g u_g) u_g \cdot \vec{\bar{A}}\right)_{i}^{n}
 -\ave{\alpha_{g}}_{a}^{n} \nabla P^{\,n} -\ave{\alpha_{g}}_{a}^{n} \nabla \delta P + g \ave{\alpha_g \rho_g}_{a}^{n}  \right. \nonumber \\
  & + & K^{n}_{wg}(\dot{m}_g^{n})^{2} + K^{n}_{i,gl}(\dot{m}^{n}_l - \dot{m}_g^{n})^2 + K^{n}_{i,ge}(\dot{m}^{n}_e - \dot{m}_g^{n})^2 + \left[\Gamma u^{'}\right]^{n} \nonumber \\
 & - & 2 K^{n}_{i,gl}(\dot{m}^{n}_l - \dot{m}_g^{n})(\dot{m}^{n+1}_l - \dot{m}_g^{n+1}) - 2 K^{n}_{wg}\dot{m}_g^{n}\dot{m}_g^{n+1} \nonumber \\
 & - & \left. 2 K^{n}_{i,ge}(\dot{m}^{n}_e - \dot{m}_g^{n})(\dot{m}^{n+1}_e - \dot{m}_g^{n+1})\vphantom{\sum_{N_{k}}}\right) \\
\label{eqn:linEntMomentumEquation}
\dot{m}_{e}^{n+1} - \dot{m}_{e}^{n} & = & \frac{\dt{}}{\dx{}}\left(- \sum^{N_{c}}_{i\,=\,1} \left( (\alpha_e \rho_e u_e) u_e \cdot \vec{\bar{A}}\right)_{i}^{n}
 -\ave{\alpha_{e}}_{a}^{n} \nabla P^{\,n} - \ave{\alpha_{e}}_{a}^{n} \nabla \delta P + g \ave{\alpha_e \rho_e}_{a}^{n}  \right. \nonumber \\
  & + & K^{n}_{we}(\dot{m}_e^{n})^{2} - 2 K^{n}_{we}\dot{m}_e^{n}\dot{m}_e^{n+1} - K^{n}_{i,ge}(\dot{m}^{n}_e - \dot{m}_g^{n})^2  \nonumber \\
 & + & \left. 2 K^{n}_{i,ge}(\dot{m}^{n}_e - \dot{m}_g^{n})(\dot{m}^{n+1}_e - \dot{m}_g^{n+1}) -\left[ \eta \Gamma u^{'} - S u^{'}\right]^{n}\vphantom{\sum_{N_{k}}}\right)
\end{IEEEeqnarray}

The momentum equations, \eqref{eqn:linLiqMomentumEquation} - \eqref{eqn:linEntMomentumEquation}, are now linear in the unknown variables $\dot{\vec{m}}^{n+1}$.
These equations are now solved for the unknown new time momenta, $\dot{\vec{m}}^{n+1}$.
The $\delta P$ is left as an unknown, creating an additional uknown on the right hand side of the linear system.
The resulting system is of the form $\displaystyle \vec{J}_{m, j} \dot{\vec{m}}_{j}^{n+1} = \vec{a}_{j} + \sum^{N_{c,j}}_{i\,=\,1} \vec{b}_{j} \delta P_{i}$.
The solution of this linear system is expressed in \eqref{eqn:momStar}.

\begin{equation}
\label{eqn:momStar}
\dot{\vec{m}}_{j}^{n+1} = \vec{J}_{m,j}^{-1} \vec{a}_{j} + \sum^{N_{c}}_{i\,=\,1} \vec{J}_{m,j}^{-1} \vec{b}_{j} \delta P_{i} = \dot{\vec{m}}^{*} + \sum^{N_{c}}_{i\,=\,1} \frac{\partial \dot{\vec{m}}_{j}}{\partial P_{i}} \delta P_{i}
\end{equation}

The definition for the new-time momenta is a function of the as of yet unknown changes in pressures that occur in the continuity volumes connected by the momentum volume.
The portion of the right hand side of \eqref{eqn:momStar} that is known, $\dot{\vec{m}}^{*}$, is considered to be the tentative new time momenta.
Once all of the momenta equations has been solved in the above manner, providing an estimated new-time momenta for each momentum volume, the domain's continuity volumes are then looped over.
The continuity equations used in this work, omitting external sources, are shown in \eqref{eqn:nlnNcgMassEquation} -- \eqref{eqn:nlnLiqMassEquation}. 
The new time velocities used for advection in the continuity equations is defined with the new time momenta, \eqref{eqn:momStar}, in conjunction with \eqref{eqn:si_vel}.

\begin{IEEEeqnarray}{rCl}
\label{eqn:nlnNcgMassEquation}
V_c \left[(\alpha_g \rho_{n})^{n+1}\right. & - & \left. (\alpha_g \rho_{n})^{n}\right] = -\dt{} \sum^{N_{f}}_{i\,=\,1}\left( \don{\alpha^{n}_g \rho^{n}_{n}}^{n+1}_{d} u^{n+1}_g  \cdot \vec{\bar{A}}\right)_{i} \\
\label{eqn:nlnVapMassEquation}
V_c\left[ \left(\alpha_g \rho_v \right)^{n+1}\right. &-& \left. \left(\alpha_g \rho_v \right)^{n}\right] = - \dt{} \sum^{N_{f}}_{i\,=\,1} \left( \don{\alpha^{n}_g \rho^{n}_v}^{n+1}_{d} u^{n+1}_g  \cdot \vec{\bar{A}}\right)_{i} + 
\dt{} \Gamma^{n+1} \\
\label{eqn:nlnGasEnergyEquation}
V_c \left[ \left( \alpha_g \rho_g h_g \right)^{n+1} \right. & - & \left. \left( \alpha_g \rho_g h_g \right)^{n} - \alpha^{n}_g ( P^{\,n+1} - P^{n} )\right ] = \dt{} \left[q_{wg} + \Gamma h^{'}_v + q_{i,v} + q_{gl}\right]^{n+1} \nonumber \\
&- &\dt{} \sum^{N_{f}}_{i\,=\,1} \left(  \don{\alpha^{n}_g \rho^{n}_g h^{n}_{g}}^{n+1}_{d} u^{n+1}_g  \cdot \vec{\bar{A}}\right)_{i} \\
\label{eqn:nlnLiqEnergyEquation}
V_c\left[\left( \alpha_l \rho_l h_l \right)^{n+1} \right. & - & \left. \left( \alpha_l \rho_l h_l \right)^{n} - \alpha^{n}_l (P^{\,n+1} - P^{\,n}) \right] = \dt{} \left[q_{wl} -\Gamma h^{'}_l +  q_{i,l} - q_{gl}\right]^{n+1} \nonumber \\
& -& \dt{} \sum^{N_{f}}_{i\,=\,1} \left( \don{\alpha^{n}_l \rho^{n}_l h^{n}_l}^{n+1}_{d} u^{n+1}_l \cdot \vec{\bar{A}} + \don{\alpha^{n}_e \rho^{n}_l h^{n}_l}^{n+1}_{d} u^{n+1}_e  \cdot \vec{\bar{A}}\right)_{i} \\
\label{eqn:nlnEntMassEquation}
V_c \left[ \left(\alpha_e \rho_l \right)^{n+1}\right. & - & \left. \left(\alpha_e \rho_l \right)^{n} \right]= -\dt{} \sum^{N_{f}}_{i\,=\,1}\left( \don{\alpha^{n}_e \rho^{n}_l}^{n+1}_{d} u^{n+1}_e  \cdot \vec{\bar{A}}\right)_{i}+ \dt{}\left[ S -\eta\Gamma \right]^{n+1} \\
\label{eqn:nlnLiqMassEquation}
V_c \left[ \left(\alpha_l \rho_l \right)^{n+1} \right. & - & \left. \left(\alpha_l \rho_l \right)^{n} \right]=  -\dt{} \sum^{N_{f}}_{i\,=\,1}\left( \don{\alpha^n_l \rho^n_l}^{n+1}_{d} u^{n+1}_l  \cdot \vec{\bar{A}}\right)_{i} \nonumber \\
&- &\dt{}\left[(1-\eta)\Gamma + S \right]^{n+1}
\end{IEEEeqnarray}

Unlike the momentum equations, the continuity equations are linearized with variables other than their conserved quantities, \eqref{eqn:independentVariables}.
This creates a more complicated linearization procedure than that used for the momenta equations.
The new-time variables in \eqref{eqn:nlnNcgMassEquation} -- \eqref{eqn:nlnLiqMassEquation} are linearized about the old-time variables with respect to the continuity variables in \eqref{eqn:independentVariables}.
The use of the \eqref{eqn:momStar} in defining the new-time velocities introduces inter-continuity volume coupling through the momentum equations dependency upon changes in pressure, $\delta P$.

\begin{equation}
\label{eqn:linSystem}
\underbrace{\left[\vec{Z}_{c, j}\right]}_{6\, \text{x}\, 6 + N_{f}} \delta \vec{C}_{j} = \underbrace{\left[\vec{J}_{c, j}\right.}_{6\, \text{x}\, 6}|{\underbrace{\left.\vec{k}_{c, j}\right]}_{6\, \text{x}\, N_{f}}}\delta \vec{C}_{j} = \vec{r}_{c,j}
\end{equation}

With the addition of the unknown pressure updates via the momenta, the six linearized continuity equations now form the linear system \eqref{eqn:linSystem}.
Additionally, while the momentum equations were fully expanded to solve for the new-time conserved quantities directly, the continuity equations instead solve for their associated updates, \eqref{eqn:linearUpdate}.

\begin{equation}
\label{eqn:linearUpdate}
\delta \vec{C}_{j} \equiv 
\begin{bmatrix}
\delta ( \alpha_{g} P_{n} )_j \\
\delta \alpha_{g, j} \\
\delta ( \alpha_{g} h_v )_j \\
\delta ( (1 - \alpha_{g} ) h_l )_j \\
\delta \alpha_{e,j} \\
\delta P_j \\ 
\delta P_i \\
\vdots \\
\delta P_{N_{f}}
\end{bmatrix}
=
\begin{bmatrix}
( \alpha_{g} P_{n})_{j}^{n+1} - (\alpha_{g} P_{g} )_{j}^{n} \\
\alpha^{n+1}_{g,j} - \alpha^{n}_{g,j} \\
( \alpha_{g} h_{v} )_{j}^{n+1} - ( \alpha_{g} h_{v} )_{j}^{n} \\
( ( 1 - \alpha_{g} ) h_{l} )_{j}^{n+1} - ( ( 1 - \alpha_{g} ) h_{l} )_{j}^{n} \\
\alpha^{n+1}_{e,j} - \alpha^{n}_{e,j} \\
 P_{j}^{n+1} - P_{j}^{n} \\
 P_{i}^{n+1} - P_{i}^{n} \\
 \vdots \\
 P_{N_{f}}^{n+1} - P_{N_{f}}^{n}
\end{bmatrix}
\end{equation}

Each continuity volume's linearized system of equations, \eqref{eqn:linSystem}, is subjected to partial LU decomposition without pivoting.
The upper triangular rectangular system for each continuity is then stored for later back substitution.
The sixth equation in \eqref{eqn:linSystem} is then scaled by its diagonal.
Since the pressure update corresponds to the last row in the system of equations, this allows for the isolation of the pressure updates.
The last row of each continuity volume's \eqref{eqn:linSystem} is then formed into a global pressure matrix, $\vec{A}_{N,N}$, and its associated right hand side, $\vec{r}$.

The two loops, one over the momentum volumes and one over the continuity volumes, form a single group of operations that act upon a given domain.
This grouping will be known hereafter as assembling the pressure matrix for a given domain.
\alg{alg:xschem} shows the two loops and their associated actions.

\begin{algo}[h!]
\setlength{\baselineskip}{0.625\baselineskip}
\begin{algorithmic}[1]
\Loop \; Momentum Volumes
	\Calculate $\vec{J}_{m, j}$, $\vec{a}_{j}$, and $\vec{b}_{j}$
	\Calculate $\dot{\vec{m}}^{*}$ and $\frac{\partial \dot{\vec{m}}}{\partial P}$
	\Calculate $\vec{F}_{m, j}$	
	\Calculate $\vec{S}_{m, j}$	
\EndLoop
\Loop \; Continuity Volumes
   	\Calculate $\vec{Z}_{c,j}$ and $\vec{r}_{c, j}$
 	\Calculate $\vec{F}_{c, j}$	
	\Calculate $\vec{S}_{c, j}$	
   	\Calculate $\vec{U}_{c, j} = \vec{L}_{c, j}^{-1} \vec{Z}_{c, j}$
   	\Calculate $\vec{r}^{*}_{c, j} = \vec{L}_{c, j}^{-1} \vec{r}_{c, j}$
   	\Set Scale $\vec{U}[6, :]_{c, j}$ and $\vec{r}[6]^{*}_{c, j}$ by $\vec{U}[6,6]_{c, j}$
   	\Set $\vec{A}_{i, :} = \vec{U}[6,:]_{c, j}$
   	\Set $\vec{res}_{i} = \vec{r}[6]^{*}_{c, j}$
\EndLoop
\end{algorithmic}
\caption{Assembling Pressure Matrix}
\label{alg:xschem}
\end{algo}

\begin{equation}
\label{eqn:pressureUpdateSystem}
\vec{A} \vec{\delta P} = \vec{res}
\end{equation}

The system, \eqref{eqn:pressureUpdateSystem}, is then solved to determine the pressure updates for the whole domain.
A loop over each continuity volume is then performed so that the pressure update can be used in solving its associated upper triangular system for the updates to the other five continuity variables in \eqref{eqn:linearUpdate}.
As the loop over the continuity volume is progressing, any momentum volume connected to the given continuity volume will have its momenta updated, \eqref{eqn:momStar} to include the contribution from that continuity volumes change in pressure. 
This update loop is shown in \alg{alg:updateVariables}.

\begin{algo}[h!]
\setlength{\baselineskip}{0.625\baselineskip}
\begin{algorithmic}[1]
\Loop \; Continuity Volumes
	\Solve $\vec{U}_{c, j} \delta \vec{C}_{c, j} = \vec{r}^{*}_{c, j}$ using $\vec{\delta P}$		
	\Loop \; Connected Flowpaths
		\Set $\dot{\vec{m}}^{*}_{j} \pluseq sig \cdot \frac{\partial \dot{\vec{m}}}{\partial P} \delta P_{j}$
	\EndLoop
\EndLoop
\end{algorithmic}
\caption{Updating Continuity and Momentum Variables}
\label{alg:updateVariables}
\end{algo}

Upon completion of this process, a single timestep is considered to have been taken.
The complete linear process is outlined in \alg{alg:linCobraAlgorithm}.

\begin{algo}[h!]
\setlength{\baselineskip}{0.625\baselineskip}
\begin{algorithmic}[1]
\Require $\vec{x}^{0}$ and $t^{0}$
\Set $n = 0$
\Loop \; Transient Loop
    \Set $t^{n+1} : = t^{n} + \dt{}$
	\Algorithm Assemble Linear Pressure Matrix \Comment{\alg{alg:xschem}}
   	\Solve $\vec{A} \vec{\delta P} = \vec{res}$
	\Algorithm Update Linear Variables \Comment{\alg{alg:updateVariables}}
	\Set $n = n + 1$
\EndLoop
\end{algorithmic}
\caption{Linear \cobra{} algorithm.}
\label{alg:linCobraAlgorithm}
\end{algo}

The solution obtained via this process is subjected to several physical and computational limits discussed in \sect{sect:algoConcerns}.

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\section{Nonlinear Solver}
\label{sect:nlnCobraSolver}
As obtained, the \cobra{} software used the single Newton step of the semi-implicit method as outlined in \sect{sect:linCobraAlg} for a timestep.
In order to evaluate the subdomain nonlinear refinement algorithm, \cobra{} needed to be modified to be able to take multiple Newton steps within a given step.
Additionally, a linesearch globalization strategy was added to the software.
The \cobra{} software needed to be modified to be able do the following:

\begin{itemize}
\item{Create a data framework for constructing vector quantities such as $\vec{x}^{k}$ and $\vec{F}$.}
\item{Correctly evaluate $\vec{F}(\vec{x}^{k})$ and $\vec{J}(x^{k})$.}
\item{Develop proper scaling of $\vec{F}(\vec{x}^{k})$.}
\item{Implement a globalization strategy for Newton's method.}
\end{itemize}

Given the formation of the governing equations from \sect{sect:linCobraAlg}, several modification were required to implement a nonlinear solver.
The correct linearization about a new-time guess value as opposed to the old time needed to be evaluated.
Each Newton step is an incremental change in the new-time variable, not a change in the independent parameters over at timestep.
Memory saving techniques had been employed in the construction of the linear solver that precluded more than one Newton step.
In particular, there had been the implicit assumption within the software that the first Newton iterate, $\vec{x}^{n+1, 0}$, was the old-time variable $\vec{x}^{n}$.
This design decision required that all subroutines involved with the evaluation of the components of both the nonlinear residual and its Jacobian be vetted for accurate usage of variables.
In addition, the assumption that $\vec{x}^{n+1, k} = \vec{x}^{n}$ produced source code that was inconsistent with an iterative Newton method.
The source code was modified to reflect the intended discretization of the governing conservation laws.
To do this, areas had to be identified where: there were implicit cancellation of terms, the new-time variables were used in place of old-time variables, and the old-time variables were used in place of new-time variables.
This required that each of the Fortran procedures involved with the calculation of the various physical parameters and operators needed to be evaluated to determine if the variables being used were correct.
Where appropriate, the software was changed to reflect the distinction between old-time and iterate variables and to introduce terms that had been assumed to be equal to zero.
Upon completion of the software audit, several architectural changes were made to expedite the implementation of the nonlinear solver.

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\subsection{Active Domain Determination}
\label{subsect:activeDomainDetermination}
In \cobra{} the smallest geometric component that can be input is the channel.
As mentioned in \ref{sect:geometry} channels inherit their geometric properties from the section in which they reside.
To create geometrically complicated problems, it is possible to enforce zero momentum in a given momentum volume.
This constraint is known as a no-flow boundary condition.
These boundary conditions decoupled adjacent continuity volumes by eliminating the flow-paths that connect them.
This boundary condition allows users to create more complicated models by isolating portions of the domain.
If an area that is isolated and is not connected to a different boundary condition, then it is known as an inactive region.
The inactive regions are thermodynamically isolated and form a closed system.
These areas of the domain do not impact the solution in the portion of the domain that has boundary values, known as the active region.
After evaluating several prototypical models, it was determined that a large portion of the domain of these problems were thermodynamically isolable.

\comment{A picture of the active vs. inactive would be nice here.}

Originally, \cobra{} would solve the momentum and continuity equations at every defined location in the problem.
The pressure matrix, $\vec{A}_{N\,x\,N}$, was sized based upon the number of volumes in the domain, $N$, not the number of active volumes, $N_{a}$.
During development it was determined that those continuity and momentum volumes which were in the inactive region would be pruned from the the simulation.
While the additional costs of including these volumes in the simulation have historically been acceptable, the use of an iterative solver would amplify the computational time spent in those regions to an unacceptable degree.
Removing these inactive volumes saved computational time by precluding the evaluation of the residuals at those locations and by modifying the size of the pressure system \eqref{eqn:pressureUpdateSystem}.
Additionally, since the inactive regions of the problem are interpreted as not being part of the system being modeled, including their equations in the residual would not provide accurate measures of convergence.

To determine which areas of the domain were active and which ones were inactive, a geometry traversing routine was written.
This routine parses the input file and proceeds to create an adjacency list data structure to represent the active portion of the domain.
The data structure allowed the active volumes to be treated independently from the memory structure of the software.
Once the active volumes were identified, the way in which the domain information was stored in memory was changed.

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\subsection{Object Oriented Modifications}
\label{subsect:ooFortran}

During this work, the architecture of \cobra{} was significantly modified.
\cobra{} provides the user with three options for the linear algebra method to be used for solving for the pressure update.
These are the Gauss elimination, the SuperLU solver \cite{Li1999}, and the Pardiso solver \cite{Schenk2006, Schenk2007}.
The SuperLU and the Pardiso solvers utilize sparse matrix storage and the Gauss elimination routine utilizes a full matrix.
The sparsity of the matrices typically encountered are such that use of the direct solver is discouraged.
Based upon input, one of these three solvers are used for finding the pressure update.
Given that the original software was written in a mixture FORTRAN 77 and Fortran 90, and as such was based upon procedural programming practices.
This meant that the memory structures for each type of solver was defined in a module.
Depending upon the input the correct arrays and initialization was performed through branching logic in the software.
Wherever interaction with the pressure matrix was required, branching code was required to access the appropriate matrix entries.
This was the default method for having multiple options for the solvers.

\begin{figure}[h!]
\singlespace\centering
\input{images/matrixClassDiagram}
\caption{Matrix Class Diagram}
\label{fig:matrixClassDiagram}
\end{figure}

This architecture was deemed to be inappropriate for the work being done.
The object oriented features in Fortran 2003/2008 standards provided an alternative method of handling the pressure matrix.
The matrix storage structure was first abstracted into an abstract \classname{matrix} class.
Each \classname{matrix} contains the number of right hand sides anticipated and the total number pressure updates, $N$.
Additionally, this class would provide the interfaces for the following procedures:

\begin{itemize}
\item{put : a procedure that sets $\vec{A}_{i,j}$ to a given value.}
\item{get : a procedure that returns $\vec{A}_{i,j}$.}
\item{scale : a procedure for scaling $\vec{A}_{i, :}$ by a given value.}
\item{reset : a procedure for setting $\vec{A} = \vec{0}$.}
\item{invert : a procedure that returns $\vec{x}$ from $\vec{A}\vec{x} = \vec{b}$.}
\end{itemize}

Given that the SuperLU and the Pardiso solvers utilize sparse matrices and the Gauss elimination routine uses a full matrix, there are two further abstract classes that inherit from \classname{matrix}; they are \classname{fullMatrix} and \classname{sparseMatrix}.
The \classname{fullMatrix} class contains an array representing $\vec{A}$.
The \classname{sparseMatrix} class contains the information required to construct a sparse matrix; however, the exact storage format is not specified in \classname{sparseMatrix}.
Both \classname{fullMatrix} and \classname{sparseMatrix} contain procedural implementations of the interfaces defined in \classname{matrix}.
There are three concrete classes that correspond to the three supported solvers: \classname{dsolveMatrix}, \classname{superluMatrix}, and \classname{pardisoMatrix}; all three implement their own linear system solving routines under the invert interface.
\classname{dsolveMatrix} is a concrete class inheriting from \classname{fullMatrix} that includes pivoting information.
\classname{superluMatrix} and \classname{pardisoMatrix} are concrete classes inheriting from \classname{sparseMatrix} that implement the matrix storage schemes for their respective solvers.
\fig{fig:matrixClassDiagram} shows the class diagram for the \classname{matrix} ecosystem.

\begin{figure}[h!]
\singlespace\centering
\input{images/solverClassDiagram}
\caption{Solver Class Diagram}
\label{fig:solverClassDiagram}
\end{figure}

Once the matrix ecosystem was developed, an abstract solver class was designed.
The \classname{solver} class contains the size $N_{a}$ of the system, a pointer to a \classname{matrix}, $\vec{A}$, and the right hand side of the linear system.
\classname{solver} specifies the interface for an initialization routine, init.
In addition \classname{solver} specifies the following procedures for manipulating the linear system:

\begin{itemize}
\item{ insert : a procedure for inserting a continuity volume's pressure equation into $\vec{A}_{i, :}$.}
\item{ solve : an interface to call the solver associated with the matrix.}
\item{ scale : a procedure for scaling $\vec{A}_{i, :}$ and $\vec{res}_{i}$.}
\item{ reset : a procedure for setting $\vec{A} = \vec{0}$ and $\vec{res} = \vec{0}$.}
\end{itemize}

There are three concrete classes that inherit from the abstract solver class: \classname{dsolveSolver}, \classname{superluSolver}, and \classname{pardisoSolver}.
Each of these concrete classes specifies an initialization routine that takes an adjacency list data structure, instantiates the \classname{matrix} pointer to the appropriate concrete subtype, and sets the appropriate matrix parameters.
By abstracting the matrices and solvers in this way, a consistent interface is provided to the rest of the software.
\fig{fig:solverClassDiagram} shows the class diagram for the \classname{solver} ecosystem.

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\subsection{Nonlinear Solver Algorithm}
\label{subsect:nlnCobraAlgo}

The nonlinear solver uses Newton's method to iteratively find solution vectors that more accurately solve the discrete algebraic system of equations.
When using the nonlinear solver, the governing equations are linearized about a tentative value $\vec{y}^{n+1, k}$, which is differs from the linear case linearizes about the old time values $\vec{y}^{n}$.
Two quantities that are important to the nonlinear solver are the residual and the update vectors, $\vec{F}^{k}$ and $\delta \vec{y}$ respectively.
The residual vector is composed of the residuals from the governing partial differential equations that are being solved.
Every momentum volume has associated with it three momentum equation residuals \eqref{eqn:nlnLiqMomentumResidual} -- \eqref{eqn:nlnEntMomentumResidual}.

\begin{IEEEeqnarray}{lCl}
\label{eqn:nlnLiqMomentumResidual}
F^{k}_{m, l} & = & \dot{m}_{l}^{n+1, k} - \dot{m}_{l}^{n} + \frac{\dt{}}{\dx{}}\left(\sum^{N_{c}}_{i\,=\,1} \left( (\alpha_l \rho_l u_l) u_l \cdot \vec{\bar{A}}\right)_{i}^{n}
 +\ave{\alpha_l}^{n}_{a} \nabla P^{\,n+1, k} - g \ave{\alpha_l \rho_l}_{a}^{n} \right. \nonumber \\
& + & \left. K^{n}_{wl}(\dot{m}_l^{n+1, k})^2 - K^{n}_{i,gl}(u^{n+1, k}_{l} - u^{n+1,k}_{g})^2 + \left[(1 - \eta)\Gamma u^{'} + S u^{'}\right]^{n} \vphantom{\sum_{N_{k}}}\right) \\
\label{eqn:nlnGasMomentumResidual}
F^{k}_{m, g} & = & \dot{m}_{g}^{n+1,k} - \dot{m}_{g}^{n} + \frac{\dt{}}{\dx{}}\left(\sum^{N_{c}}_{i\,=\,1} \left( (\alpha_g \rho_g u_g) u_g  \cdot \vec{\bar{A}}\right)_{i}^{n}  +\ave{\alpha_g}^{n}_{a} \nabla P^{\,n+1, k} - g \ave{\alpha_g \rho_g}_{a}^{n} \right.\nonumber \\
& + & \left. K^{n}_{wg}(\dot{m}_g^{n+1, k})^2 + K^{n}_{i,gl}(u^{n+1, k}_{l} - u^{n+1, k}_{g})^2 + K^{n}_{i,ge}(u^{n+1,k}_{e} - u^{n+1,k}_{g})^2 - (\Gamma u^{'})^{n} \vphantom{\sum_{N_{k}}}\right) \\
\label{eqn:nlnEntMomentumResidual}
F^{k}_{m, e} & = & \dot{m}_{e}^{n+1, k} - \dot{m}_{e}^{n} + \frac{\dt{}}{\dx{}}\left(\sum^{N_{c}}_{i\,=\,1} \left( (\alpha_e \rho_l u_e) u_e  \cdot \vec{\bar{A}}\right)_{i}^{n} + \ave{\alpha_{e}}^{n}_{a} \nabla P^{\,n+1, k} - g \ave{\alpha_e \rho_l}^{n}_{a} \right. \nonumber \\
& + & \left. K^{n}_{we}(\dot{m}_e^{n+1, k})^2 - K^{n}_{i,ge}(u^{n+1, k}_{e} - u^{n+1, k}_{g})^2 + \left[\eta \Gamma u^{'} - S u^{'}\right]^n\vphantom{\sum_{N_{k}}}\right)
\end{IEEEeqnarray}

Likewise, each continuity volume has associated with it six residuals representing the mass and energy equations \eqref{eqn:nlnNcgMassResidual} -- \eqref{eqn:nlnLiqMassResidual}.

\begin{IEEEeqnarray}{lCl}
\label{eqn:nlnNcgMassResidual}
F^{k}_{c, n} & = & V_c\left[ (\alpha_g \rho_{n})^{n+1, k} -(\alpha_g \rho_{n})^{n}\right] +\dt{} \sum^{N_{f}}_{i\,=\,1}\left( \don{\alpha^{n}_g \rho^{n}_{n}}^{n+1,k}_{d} u^{n+1, k}_{g}  \cdot \vec{\bar{A}}\right)_{i} \\
\label{eqn:nlnVapMassResidual}
F^{k}_{c, v} & = & V_c \left[\left(\alpha_g \rho_v \right)^{n+1, k} - \left(\alpha_g \rho_v \right)^{n}\right] + \dt{} \sum^{N_{f}}_{i\,=\,1} \left( \don{\alpha^{n}_g \rho^{n}_v}^{n+1,k}_{d} u^{n+1, k}_{g}  \cdot \vec{\bar{A}}\right)_{i} - \dt{} \Gamma^{n+1, k} \\
\label{eqn:nlnGasEnergyResidual}
F^{k}_{e, g} & = & V_c \left[\left( \alpha_g \rho_g h_g \right)^{n+1, k} - \left( \alpha_g \rho_g h_g \right)^{n} - \alpha^{n}_{g} ( P^{\,n+1, k} - P^{\,n} ) \right] \nonumber \\
& - & \dt{} \left[q_{wg} + \Gamma h^{'}_v + q_{i,v} + q_{gl}\right]^{n+1, k} + \dt{} \sum^{N_{f}}_{i\,=\,1} \left(\don{\alpha^{n}_g \rho^{n}_g h_g^{n}}^{n+1,k}_{d} u^{n+1, k}_g  \cdot \vec{\bar{A}}\right)_{i} \\
\label{eqn:nlnLiqEnergyResidual}
F^{k}_{e, l} & = & V_c\left[\left( \alpha_l \rho_l h_l \right)^{n+1,k} - \left( \alpha_l \rho_l h_l \right)^{n} - \alpha^{n}_l (P^{\,n+1,k} - P^{\,n})\right] - \dt{} \left[q_{wl} -\Gamma h^{'}_l +  q_{i,l} - q_{gl}\right]^{n+1,k}    \nonumber \\
& +& \dt{} \sum^{N_{f}}_{i\,=\,1} \left( \don{\alpha^{n}_l \rho^{n}_l h^{n}_l}^{n+1,k}_{d} u^{n+1,k}_l \cdot \vec{\bar{A}} + \don{\alpha^{n}_e \rho^{n}_l h^{n}_l}^{n+1,k}_{d} u^{n+1,k}_e  \cdot \vec{\bar{A}}\right)_{i} \\
\label{eqn:nlnEntMassResidual}
F^{k}_{m, e} & = & V_c \left(\alpha_e \rho_l \right)^{n+1,k} - V_c \left(\alpha_e \rho_l \right)^{n} + \dt{} \sum^{N_{f}}_{i\,=\,1}\left( \don{\alpha^{n}_e \rho^{n}_l}^{n+1, k}_{d} u^{n+1,k}_e  \cdot \vec{\bar{A}}\right)_{i} \nonumber \\
&-& \dt{}\left[ S -\eta\Gamma \right]^{n+1,k} \\
\label{eqn:nlnLiqMassResidual}
F^{k}_{m, l} & = & V_c \left(\alpha_l \rho_l \right)^{n+1,k} - V_c \left(\alpha_l \rho_l \right)^{n} + \dt{} \sum^{N_{f}}_{i\,=\,1} \left(\don{\alpha^n_l \rho^n_l}^{n+1,k}_{d} u^{n+1, k}_l \cdot \vec{\bar{A}}\right)_{i}   \nonumber \\
&+& \dt{}\left[(1-\eta)\Gamma + S \right]^{n+1, k}
\end{IEEEeqnarray}

The residuals from every volume in the active domain, both continuity and momentum, are assembled into the $\vec{F}^{k}$ vector.
The accuracy of a given solution can be measured by a norm of the residual vector of the nonlinear system.
If the exact solution for the nonlinear system were know, every residual would be identically $\vec{0}$; however, in practice the residual will never be identically zero.
As such it is necessary to discuss the various means by which a solution for a time-step is determined to be accurate enough.
While the Newton step is being evaluated, the residual is evaluated $\vec{F}(\vec{x}^{n+1,k})$.
Once the Newton update, $\delta \vec{x}^{k}$, has been calculated, the residual is reevaluated at $\vec{F}(\vec{x}^{n+1, k+1})$.
In this way the accuracy of the solution vector, $\vec{x}^{n+1}$, can be compared to determine how well the update vector performed in providing a more accurate solution.
In \cobra{} there are three way in which the iterative newton loop can be terminated.
One way to terminate the Newton loop is to have the number of Newton iterates, $k$, exceed a specified threshold, $\kmax{}$.
Another way to terminate the Newton loop is to have the relative update vector, \eqref{eqn:nlnUpdateVector}, drops below a specified threshold $\dtol{}$.

\begin{equation}
\label{eqn:nlnUpdateVector}
\delta \tilde{\vec{x}}^{k} = \frac{\delta \vec{x}^{k}}{\vec{x}^{n+1, k}} = \frac{ \vec{x}^{n+1, k+1} - \vec{x}^{n+1, k}}{\vec{x}^{n+1,k}}
\end{equation}

Finally, the Newton loop will terminate if the scaled residual vector, \eqref{eqn:nlnScaledResidual} drops below a specified threshold, $\ftol{}$.

\begin{equation}
\label{eqn:nlnScaledResidual}
\tilde{\vec{F}}^{k} = (\vec{S}^{-1}\vec{F})^{k}
\end{equation}

The scaling vector, $\vec{S}^{k}$, will be discussed in detail in \sect{sect:nlnScaling}.
The convergence determination logic for when to end the Newton loop is given in \alg{alg:nlnConvergence}.

\begin{algo}[h!]
\setlength{\baselineskip}{0.625\baselineskip}
\begin{algorithmic}[1]
\If{ $||\tilde{\vec{F}}^{k+1}||_{2} \leq \ftol{}$}
	\State \textbf{end} Newton Loop
\ElsIf{ $||\delta \tilde{\vec{x}}^{k}||_{2} \leq \dtol{}$}
	\State \textbf{end} Newton Loop
\ElsIf{ $k > \kmax{}$}
	\State \textbf{end} Newton Loop
\EndIf
\end{algorithmic}
\caption{Convergence Determination of Newton Loop}
\label{alg:nlnConvergence}
\end{algo}

In order to determine convergence according to \alg{alg:nlnConvergence}, it is necessary to have the values of $\vec{F}^{k+1}$ and $\vec{S}^{k+1}$.
This is accomplished by looping over the domain and assembling the pressure matrix again.
According to \alg{alg:xschem}, the residual and scale factor are both evaluated during this process.
If \alg{alg:nlnConvergence} determines that the Newton loop should not end, then the pressure matrix is already assembled and can be solved for the new update vector.
However, if the Newton loop is terminated, then there are changes that were made during \alg{alg:xschem} that need to be undone.
\alg{alg:nlnCobraAlgorithm} contains the current algorithmic implementation of the nonlinear semi-implicit method.

\begin{algo}[h!]
\setlength{\baselineskip}{0.625\baselineskip}
\begin{algorithmic}[1]
\Require $\vec{x}^{0}$ and $t^{0}$
\Set $n = 0$
\Loop \; Transient Loop
    \Set $t^{n+1} : = t^{n} + \dt{}$
    \Set $k = 0$
	\Algorithm Assemble Nonlinear Pressure Matrix	 \Comment{\alg{alg:xschem}}
	\Solve $\vec{A}^{k} \vec{\delta P}^{k} = \vec{res}^{k}$
	\Algorithm Update Nonlinear Variables \Comment{\alg{alg:updateVariables}} 
    \Loop \; Newton Loop
		\Algorithm Assemble Nonlinear Pressure Matrix \Comment{\alg{alg:xschem}}
		\Algorithm Convergence Determination \Comment{\alg{alg:nlnConvergence}}
		\If{ \textbf{end} Newton loop}
			\State Undo partial Newton Step
			\State \textbf{break} Newton Loop 
		\EndIf		
		\Set $k \pluseq 1$
		\Solve $\vec{A}^{k} \vec{\delta P}^{k} = \vec{res}^{k}$
		\Algorithm Update Nonlinear Variables \Comment{\alg{alg:updateVariables}}
	\EndLoop
	\Set $n \pluseq 1$
\EndLoop
\end{algorithmic}
\caption{Nonlinear \cobra{} algorithm.}
\label{alg:nlnCobraAlgorithm}
\end{algo}

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\subsection{Globalization Strategy}
\label{subsect:nlnGlobalStrategy}

\comment{
Here will be another algorithm that has the globalization loop.
This section needs some work.
}

A globalization strategy was implemented for the Newton algorithm.
A linesearch algorithm was chosen for this.
The second is the globalization loop termination criteria.
The globalization strategy implemented in \cobra{} is a line search algorithm \cite{Dennis1996}.
The two globalization loop termination criteria are:

\begin{enumerate}
\item{$\frac{1}{2}||\vec{F}^{k+1, j}||^{2}_{2} < \frac{1}{2}||\vec{F}^{k}||^{2}_{2} - \alpha ||\vec{F}^{k}||^{2}_{2}$ }
\item{$\sqrt{\lambda_{j+1}}||\delta \tilde{\vec{x}}^{k}||_{2} < \dtol{}$}
\end{enumerate}

If neither of the loop termination criteria are met, then a step-length parameter, $\lambda_j$, is calculated.
On the first pass through the globalization loop within a given Newton step, a quadratic backtracking model is adopted.
On subsequent passes, a cubic-backtracking model is used.

\begin{algo}[h!]
\setlength{\baselineskip}{0.625\baselineskip}
\begin{algorithmic}[1]
\Require $\vec{x}^{0}$ and $t^{0}$
\Set $n = 0$
\Loop \; Transient Loop
    \Set $t^{n+1} : = t^{n} + \dt{}$
    \Set $k = 0$
	\Algorithm Assemble Nonlinear Pressure Matrix	 \Comment{\alg{alg:xschem}}
	\Solve $\vec{A}^{k} \vec{\delta P}^{k} = \vec{res}^{k}$
	\Algorithm Update Nonlinear Variables \Comment{\alg{alg:updateVariables}} 
    \Loop \; Newton Loop
		\Algorithm Assemble Nonlinear Pressure Matrix \Comment{\alg{alg:xschem}}
		\Algorithm Globalization Loop \Comment{\alg{alg:globalization}}
		\Algorithm Convergence Determination \Comment{\alg{alg:nlnConvergence}}
		\If{ \textbf{end} Newton loop}
			\State Undo partial Newton Step
			\State \textbf{break} Newton Loop 
		\EndIf		
		\Set $k \pluseq 1$
		\Solve $\vec{A}^{k} \vec{\delta P}^{k} = \vec{res}^{k}$
		\Algorithm Update Nonlinear Variables \Comment{\alg{alg:updateVariables}}
	\EndLoop
	\Set $n \pluseq 1$
\EndLoop
\end{algorithmic}
\caption{Nonlinear \cobra{} with Globalization Strategy.}
\label{alg:nlnGlobalizedAlgorithm}
\end{algo}

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\subsection{Quality Control}
\label{subsect:nlnDevelopment}
The development of the nonlinear solver within \cobra{} took place under strict quality assurance guidelines.
At every step of the development, the linear solver was required to maintain the same solution.
This verification was dependent upon a larger number of verification and assessment problems.
The output of the unmodified \cobra{} and the modified \cobra{} software was compared to machine precision.
It was required that either the results of the two simulations be identical or that the reason for the difference be identified and understood.
The \cobra{} software has the ability to repeat a time-step.
As such, it was required that the backup capabilities continued to work while nonlinear solver was being implemented.
Additionally, testing was done to ensure that the ability to restart the software mid-simulation was unaffected.
While adding time to the development cycle, the overhead of the quality assurance procedures ensured that the linear solver could continue to be used for design purposes.

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\subsection{Nonlinear Input File}
\label{subsect:nlnCobraInputFile}
The primary input file for \cobra{} is fixed format, so it was decided that a separate input file for the nonlinear solver would provide the most flexibility when running simulations.
This decision allowed for existing models to be run in nonlinear mode without modification of the actual input file.
The presence of the file ``\classname{nwt.cob}" triggers the input processing routine for the nonlinear solver.
There are three parameters that need to be present in the input file; in order they are \kmax{},\ftol{}, and \dtol{}, each on a separate line. 
If the file is present but empty, then the default values are used; they are $35$, \expneg{1.0}{5}, and \expneg{1.0}{10}, respectively.

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\section{Algorithmic Considerations}
\label{sect:algoConcerns}

\comment{
This section needs to be reviewed.
In particular, there are several algorithmic issues that need to be added.
The relinearization of the momenta to achieve equal velocities is important.
I also believe this to be a rather disjoint section.
}

The solution algorithms outlined in \sect{sect:linCobraAlg} and \sect{sect:nlnCobraSolver} have several algorithmic issues that need to be addressed.
Among these issues are phase appearance and disappearance (hereafter referred to as phase transition), timestep solution acceptance criteria, and timestep size selection.

Given that the governing conservation laws in thermal-hydraulic analyses are those of two-phase flow, phase transition is integral to accurate simulations.
The methods for addressing phase transitions within two-phase analysis software are ad hoc procedures that vary from software to software.
While each algorithmic implementation of the various methods addresses this issue out of necessity, there is no systematic or optimal way of doing so.
However, certain physical limits have been identified that need to be considered \cite{Bestion2000}.

When the two-phase flow within \cobra{} approaches that of single-phase flow, there is a lower limit imposed upon the volume fraction of the phase that is disappearing.
This means that \cobra{} does not transition between the two-phase flow governing equations and the governing equations for single-phase flow.
Even during simulated single-phase flow, the non-dominant phase is still present, but it is at a very small volume fraction.
However, since the \ncgs{} and the vapor fields share a common volume fraction, the partial pressure of the \ncgs{} is allowed to go to zero. 
Since \cobra{} incorporates two liquid fields, the lower limit for the aggregate liquid volume fraction, $\alpha_e + \alpha_l$, is equally divided between the two liquid fields.
As a phase approaches depletion, $\alpha_k \rightarrow \alpha_{k,\text{min}}$, the velocity of the depleting phase is required to approach that of the remaining phase.
This velocity equilibrium is imposed by artificially increasing the interfacial drag between the two phases.

However, there is a subtle issue created by artificially increasing the interfacial drag between the two phases.
The increased interfacial drag will dominate the residual for the momentum equation of the phase that is not disappearing.
It was determined that the two coefficients should be kept the same.
Since the new-time velocity is what is forced to be equal by the interfacial drag, at the beginning of the next timestep, the old time velocity is not equal to the new-time velocity at the end of the previous timestep.
This meant that at the beginning of every timestep where the simulation was effectively single phase, there was slip between the two phases even though there was no slip at the end of the previous timestep.
To assist in removing this problem, the velocity of the depleted phase is relinearized every timestep to be equal to within round off of the dominant phase.
The linearization point is determined by the ratio of the macroscopic densities.
 
Upon completion of a timestep within \cobra{}, there are certain constraints that are imposed upon the independent parameters.
These constraints are designed to deal with the possibility that the obtained solution may not be an accurate one.
After the single Newton step, the updated parameters are evaluated to determine their validity.
There are two ways of resolving potentially invalid solutions: parameter limiting and timestep failure.
The limiting procedure can either truncate the updated parameter so that it falls within a valid range, or the timestep can be considered a failure.
When a predicted volume fraction falls outside of its valid range, it is truncated to obey the constraint of equation \eqref{eqn:volume_fraction}.

\begin{equation}
\label{eqn:volume_fraction}
\alpha_{k,\text{min}} \leq \alpha_k \leq \alpha_{k,\text{max}} 
\end{equation}

There are also limits placed upon the changes of the thermodynamic parameters within a timestep in \cobra{}.
The constrained thermodynamic parameters and the limits imposed upon their per-timestep changes are listed below.

\begin{itemize}
\item{Change of phasic enthalpy cannot be greater than $45$ [$\frac{\text{BTU}}{\lbm{}}$].}
\item{Change in pressure cannot be greater than $20$ [psia].}
\item{Change in partial pressure of the \ncg{} field cannot be greater than $20$ [psia].}
\item{Thermodynamic variables would fall outside of the range of validity of the equations of state.}
\end{itemize}

The first three limits are an attempt to mitigate an initial guess that may be outside of the Newton step's radius of convergence.
If any of the above limits are exceeded, the timestep is considered a failure and is repeated with a smaller timestep size.

Another algorithmic concern is how to identify a potentially poor linearization point in the presence of phase transitions. 
This can be considered a predictive error correction technique.
It uses information from the explicit portion of the nonlinear residual to identify situations where the linearization point may be poor.
In \cobra{} this method is used only for the prediction of \ncg{} appearance.

To determine the \dt{} at each timestep \cobra{} uses an adaptive timestep selection algorithm.
This algorithm is based upon a maximum permissible timestep based upon the material Courant limit.
The \dt{} for any timestep is given by \eqref{eqn:time_step}.

\begin{equation}
\label{eqn:time_step}
\dt{}^{n \rightarrow n+1} = \max\left[ \dt{}_{\text{MIN}}, \min\left[1.2 \dt{}^{n-1 \rightarrow n}, 0.85 \dt{}_{\text{CRNT}}, \dt{}_{\text{MAX}} \right]\right]
\end{equation}

$\dt{}_{\text{CRNT}}$ is the most restrictive Courant number calculated for both axial and transverse flow, and a \dt{} that is based upon the time calculated to empty a given volume of the mass of a given field.
The most restrictive of the Courant timestep is used as $\dt{}^{n \rightarrow n+1}$.


%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\section{Operator-Based Scaling}
\label{sect:nlnScaling}

As part of the \cobra{} modification a novel operator based scaling has been developed to obtain meaningful convergence thresholds.
An important aspect of the nonlinear solver outlined above is the convergence criteria.
The iterative solver depends upon the scaled residual to determine when convergence has been achieved.
In particular, various norms of the residual are evaluated to measure the degree to which the nonlinear system of algebraic equations are being satisfied.
The evaluation of residual norms encourages the use of a scaling matrix for the residual vector.
Without scaling the residual has several negative characteristics.
The different equations will have different scales at a given point in time because of the physical quantities that they represent.
Over the course of the transient the magnitude of any given equation can vary dramatically.
Summing equations with different units is not good.
When the summation occurs those equations whose terms are the largest may have an unscaled residual that is orders of magnitude greater than others.
This will mean that any norm taken of the residuals will be subject to a bias towards those equations with the largest numerical value by virtue of their units.

Here is a list of the residuals and their units.
For a given continuity volume, the nonlinear residual will have six components: four for the conservation of mass and two for the conservation of energy.
For each momentum volume, the three conservation of momentum equations will form the three components of the nonlinear residual.
These residuals have the units of the conserved quantities for their corresponding PDEs; \tab{tab:scaling_units_scales} shows the units for the different conservation equations.

\begin{table}[ht]
\centering
\input{tables/residuals_and_units}
\caption{Residuals and their units.}
\label{tab:scaling_units_scales}
\end{table}

For the aforementioned reasons, it is desirable to scale the residuals.
A challenge that has been addressed in this work is the development of a method for scaling of these residuals that is based upon the local physics of interest at any given point in the transient.
In constructing this scaling factor it was determined that the following characteristics were desirable:

\begin{itemize}
\item{$(S_{i}^{k})^{-1} F^{k}_i \approx 1$ when $\vec{x}^{k}$ is a "poor" solution.}
\item{$(S_{i}^{k})^{-1} F^{k}_i \rightarrow 0$ when phase $i$ disappears.}
\item{$0 \leq \abs{(S_{i}^{k})^{-1} F^{k}_{i}} \leq 1 $ for all values of $\vec{x}^{k}_i$.}
\end{itemize}

This dynamic behavior of the residual necessitates a method for scaling that adapts to relevant physical situations.
The scaling method developed during this work is an operator-based approach.
The governing PDEs can be viewed as a collection of operators, both linear and nonlinear, acting upon the vector of independent parameters.
The summation of these operators must balance to zero for the nonlinear equation to be satisfied.
The scaling factor developed uses the magnitudes of these operators to determine an absolute measure of the physics processes occurring in a given volume.
This is accomplished by summing the absolute value of the different discrete operators in the governing equations.
This scaling creates a relative measure of the nonlinear residual when compared to the magnitude of the physics involved in the process.


\begin{IEEEeqnarray}{lCl}
\label{eqn:nlnLiqMomentumScale}
S^{k}_{m, l} & = & \frac{\dt{}}{\dx{}} \left[\abs{\frac{\dx{} \left[\dot{m}_{l}^{n+1, k} - \dot{m}_{l}^{n}\right]}{\dt{}}} + \abs{\sum^{N_{c}}_{i\,=\,1} \left( (\alpha_l \rho_l u_l) u_l \cdot \vec{\bar{A}}\right)^{n}_{i}} +\abs{\ave{\alpha_l}^{n}_{a} \nabla P^{\,n+1, k}} + \abs{g \ave{\alpha_l \rho_l}_{a}^{n}} \right.\nonumber \\
& + & \left. \abs{K^{n}_{wl}(\dot{m}_l^{n+1, k})^2} + \abs{K^{n}_{i,gl}(u^{n+1, k}_{l} - u^{n+1,k}_{g})^2} + \abs{\left[(1 - \eta)\Gamma u^{'}\right]^{n}} + \abs{\left[S u^{'}\right]^{n}} \vphantom{\abs{\frac{\dx{} \left[\dot{m}_{l}^{n+1, k} - \dot{m}_{l}^{n}\right]}{\dt{}}}} \right] \\
\label{eqn:nlnGasMomentumScale}
S^{k}_{m, g} & = & \frac{\dt{}}{\dx{}} \left[\abs{\frac{\dx{} \left[ \dot{m}_{g}^{n+1,k} - \dot{m}_{g}^{n}\right]}{\dt{}}} + \abs{\sum^{N_{c}}_{i\,=\,1} \left( (\alpha_g \rho_g u_g) u_g  \cdot \vec{\bar{A}}\right)_{i}^{n}}  +\abs{\ave{\alpha_g}^{n}_{a} \nabla P^{\,n+1, k}} + \abs{g \ave{\alpha_g \rho_g}_{a}^{n}} \right. \nonumber \\
& + & \abs{K^{n}_{wg}(\dot{m}_g^{n+1, k})^2} + \abs{K^{n}_{i,gl}(u^{n+1, k}_{l} - u^{n+1, k}_{g})^2} + \abs{K^{n}_{i,ge}(u^{n+1,k}_{e} - u^{n+1,k}_{g})^2} \nonumber \\
& + & \left. \abs{\left[\Gamma u^{'}\right]^{n}} \vphantom{\abs{\frac{\dx{} \left[\dot{m}_{l}^{n+1, k} - \dot{m}_{l}^{n}\right]}{\dt{}}}} \right]\\
\label{eqn:nlnEntMomentumScale}
S^{k}_{m, e} & = & \frac{\dt{}}{\dx{}} \left[\abs{\frac{\dx{} \left[\dot{m}_{e}^{n+1, k} - \dot{m}_{e}^{n}\right]}{\dt{}}} + \abs{\sum^{N_{c}}_{i\,=\,1} \left( (\alpha_e \rho_l u_e) u_e  \cdot \vec{\bar{A}}\right)_{i}^{n}} + \abs{\ave{\alpha_{e}}^{n}_{a} \nabla P^{\,n+1, k}} + \abs{g \ave{\alpha_e \rho_l}^{n}_{a}} \right. \nonumber \\
& + & \left. \abs{K^{n}_{we}(\dot{m}_e^{n+1, k})^2} + \abs{K^{n}_{i,ge}(u^{n+1, k}_{e} - u^{n+1, k}_{g})^2} + \abs{\left[\eta \Gamma u^{'}\right]^{n}} +\abs{\left[S u^{'}\right]^{n}} \vphantom{\abs{\frac{\dx{} \left[\dot{m}_{l}^{n+1, k} - \dot{m}_{l}^{n}\right]}{\dt{}}}} \right]
\end{IEEEeqnarray}

For the momentum equations, \eqref{eqn:nlnLiqMomentumEquation} -- \eqref{eqn:nlnEntMomentumEquation}, the scaled residuals are shown in \eqref{eqn:nlnLiqMomentumScale} -- \eqref{eqn:nlnEntMomentumScale}.
Likewise, the scale factors for the continuity equations, \eqref{eqn:nlnNcgMassEquation} -- \eqref{eqn:nlnLiqMassEquation}, are given in  \eqref{eqn:nlnNcgMassScale} -- \eqref{eqn:nlnLiqMassScale}.

\begin{IEEEeqnarray}{lCl}
\label{eqn:nlnNcgMassScale}
S^{k}_{c, n} & = & \dt{}\left[\abs{\frac{V_c\left[(\alpha_g \rho_{n})^{n+1, k} -(\alpha_g \rho_{n})^{n}\right]}{\dt{}}} + \sum^{N_{f}}_{i\,=\,1}\abs{\left( \don{\alpha^{n}_g \rho^{n}_{n}}^{n+1,k}_{d} u^{n+1, k}_{g}  \cdot \vec{\bar{A}}\right)}_{i} \right]\\
\label{eqn:nlnVapMassScale}
S^{k}_{c, v} & = & \dt{}\left[\abs{\frac{V_c \left[\left(\alpha_g \rho_v \right)^{n+1, k} - \left(\alpha_g \rho_v \right)^{n}\right]}{\dt{}}} + \sum^{N_{f}}_{i\,=\,1} \abs{ \left( \don{\alpha^{n}_g \rho^{n}_v}^{n+1,k}_{d} u^{n+1, k}_{g}  \cdot \vec{\bar{A}}\right)}_{i} \right. \nonumber \\
& + & \left.  \abs{\Gamma^{n+1, k}} \vphantom{\abs{\frac{V_c \left[\left(\alpha_g \rho_v \right)^{n+1, k} - \left(\alpha_g \rho_v \right)^{n}\right]}{\dt{}}}} \right]\\
\label{eqn:nlnGasEnergyScale}
S^{k}_{e, g} & = & \dt{}\left[\abs{\frac{V_c \left[\left( \alpha_g \rho_g h_g \right)^{n+1, k} - \left( \alpha_g \rho_g h_g \right)^{n}\right]}{\dt{}}} +\abs{\frac{V_c \alpha^{n}_{g} ( P^{n+1, k} - P^{n} )}{\dt{}}} + \abs{q_{wg}^{n+1, k}} \right. \nonumber \\
& + & \left. \abs{\left[\Gamma h^{'}_v\right]^{n+1,k}} + \abs{q_{i,v}^{n+1,k}} +\abs{q^{n+1,k}_{gl}} + \sum^{N_{f}}_{i\,=\,1} \abs{\left(\don{\alpha^{n}_g \rho^{n}_g h_g^{n}}^{n+1,k}_{d} u^{n+1, k}_g  \cdot \vec{\bar{A}}\right)}_{i} \vphantom{\abs{\frac{V_c \left[\left( \alpha_g \rho_g h_g \right)^{n+1, k} - \left( \alpha_g \rho_g h_g \right)^{n}\right]}{\dt{}}}} \right]\\
\label{eqn:nlnLiqEnergyScale}
S^{k}_{e, l} & = & \dt{}\left[ \abs{\frac{V_c\left[\left( \alpha_l \rho_l h_l \right)^{n+1,k} - \left( \alpha_l \rho_l h_l \right)^{n}\right]}{\dt{}}} + \abs{\frac{V_c \alpha^{n}_l (P^{\,n+1,k} - P^{\,n})}{\dt{}}} + \abs{q^{n+1, k}_{wl}} \right . \nonumber \\
& + & \abs{\left[\Gamma h^{'}_l\right]^{n+1}} + \abs{q^{n+1,k}_{i,l}} + \abs{q_{gl}^{n+1,k}} + \sum^{N_{f}}_{i\,=\,1}\abs{\left( \don{\alpha^{n}_l \rho^{n}_l h^{n}_l}^{n+1,k}_{d} u^{n+1,k}_l \cdot \vec{\bar{A}}\right)}_{i} \nonumber \\
& + & \left. \sum^{N_{f}}_{i\,=\,1}\abs{\left(\don{\alpha^{n}_e \rho^{n}_l h^{n}_l}^{n+1,k}_{d} u^{n+1,k}_e  \cdot \vec{\bar{A}}\right)}_{i} \vphantom{ \abs{\frac{V_c\left[\left( \alpha_l \rho_l h_l \right)^{n+1,k} - \left( \alpha_l \rho_l h_l \right)^{n}\right]}{\dt{}}}} \right] \\
\label{eqn:nlnEntMassScale}
S^{k}_{m, e} & = & \dt{} \left[ \abs{\frac{V_c \left[\left(\alpha_e \rho_l \right)^{n+1,k} - \left(\alpha_e \rho_l \right)^{n}\right]}{\dt{}}} + \sum^{N_{f}}_{i\,=\,1}\abs{\left( \don{\alpha^{n}_e \rho^{n}_l}^{n+1, k}_{d} u^{n+1,k}_e  \cdot \vec{\bar{A}}\right)}_{i} \right. \nonumber \\
& + & \left. \abs{S^{n+1, k}} + \abs{\left[\eta\Gamma \right]^{n+1,k}} \vphantom{\abs{\frac{V_c \left[\left(\alpha_e \rho_l \right)^{n+1,k} - \left(\alpha_e \rho_l \right)^{n}\right]}{\dt{}}}} \right] \\
\label{eqn:nlnLiqMassScale}
S^{k}_{m, l} & = & \dt{}\left[\abs{\frac{V_c \left[\left(\alpha_l \rho_l \right)^{n+1,k} - \left(\alpha_l \rho_l \right)^{n}\right]}{\dt{}}} + \sum^{N_{f}}_{i\,=\,1} \abs{\left(\don{\alpha^n_l \rho^n_l}^{n+1,k}_{d} u^{n+1, k}_l \cdot \vec{\bar{A}}\right)}_{i} \right. \nonumber \\
& + & \left. \abs{\left[(1-\eta)\Gamma\right]^{n+1,k}} + \abs{S^{n+1, k}} \vphantom{\abs{\frac{V_c \left[\left(\alpha_l \rho_l \right)^{n+1,k} - \left(\alpha_l \rho_l \right)^{n}\right]}{\dt{}}}} \right]
\end{IEEEeqnarray}

The issue of phase transition also needed to be considered during this work.
Since \cobra{} does not actually transition the governing equations to those for single-phase flow, there will always be a nonlinear residual for those phases that are nominally absent.
It was determined that the effects of maintaining a depleted phase in the system of equations when solving the nonlinear problem created spurious convergence issues when using these scale factor.
The unscaled residuals would be on the order of machine round-off.
The operator based scaling factors for these residuals would also be within orders of magnitude of machine round-off.
This created the situation where the scaled nonlinear residual for the depleted field would be of $\mathcal{O}$(1).
These depleted residuals would dominate the norms used to determine convergence.
To overcome this deficiency it was determined that when a phase or field began to deplete, the scaling factor would be scaled up to create an artificial decrease in the residual to counter the artificial presence of the depleted field.
This scaling is shown by \eqref{eqn:scaling_factor_small}.

\begin{equation}
\label{eqn:scaling_factor_small}
S_k = \max[1.0, \left(C_1 \frac{\alpha_{k,\text{MIN}}}{\alpha_k}\right)^{C_2} ] S_k
\end{equation}

For this work, the constant $C_1$ was set equal to 100, and the exponent $C_2$ was set equal to 10.
This particular phase transition scaling produced the regular operator scaling factor when the volume fraction of a phase is at least two orders of magnitude greater than the minimum volume fraction for that phase.
This drove the scaled residuals for phases that were nominally not present to well below those residuals for equations that were active.

Another phase depletion limit was a floor placed upon the scale factor.
For each equation, the scale factor was limited to the minimum possible value of the conserved quantity based upon the volume fraction limits.
For the mass equations it would be the minimum macroscopic density of the given field based upon the minimum volume fraction for that field.

\begin{table}[ht]
\centering
\input{tables/minimum_conserved_values}
\caption{Minimum conserved quantities for conservation equations.}
\label{tab:minimumConservedValues}
\end{table}

\tab{tab:minimumConservedValues} shows the floors for the various residuals.
These floors are based update during the iterative process.

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\section{Convergence Metric}
\label{sect:temporal_convergence}

An important factor in thermal-hydraulic safety analysis is the temporal convergence of the solution.
A definition for a temporally converged solution is required.
In theory, a temporally converged solution is one where the local truncation error due to the discrete approximation of the temporal integral is orders of magnitude below both the engineering scales of interest and precision of the physical models being used in the simulation.
Unfortunately, the precise measurement of the error in a simulation requires that an analytic solution be available for comparison.
During the simulation of physically realistic systems, there is rarely an analytic solution against which to compare.
This situation requires a slightly different definition of a temporally converged solution --- a definition that does not depend upon accurately measuring the local truncation error.

An alternative definition for temporal convergence could be ``as the timestep size is reduced, the change in the solution is small enough."
While commonly used, this definition is subjective.
Traditionally, ``change in solution" is addressed in a very qualitative manner.
Engineering judgment of which parameters of the solution are of interest is required.
These parameters may include items of regulatory concern such as peak clad temperature or peak system pressure.
Examining only engineering parameters of interest is a weakness.
This locality means that the entire solution domain is not being considered.
Depending upon the context in which the work is being done, the degree of ``small enough" may be nothing more than looking at a graph of the parameter of interest and using engineering judgment to say that ``those two graphs look about the same."
In some cases, a more quantifiable measure may be used.
An example of a quantifiable metric would be if two simulations with different \dtmax{} are classified as dissimilar if the two solutions produce a ``calculated peak fuel cladding temperature different by more than $50\,^{\circ}\mathrm{F}$" \cite{CFR10}.

While it may be that the change in the chosen parameters of interest does not exceed the limits placed upon it as the timestep size is refined, that behavior does not imply that the solution obtained is the solution to the discrete nonlinear problem.
A metric that can quantify the degree to which the obtained solution satisfies the nonlinear system of equations would be of great value.
The previously mentioned work into nonlinear convergence shows that a solution may be timestep size insensitive but not be the converged solution of the discretized problem \cite{Knoll2001}.
If the nonlinearities of the discrete governing equations are not resolved, then the temporal convergence rate can be degraded.
This degradation can produce results that qualitatively appear to be converged due to an almost zeroth order of temporal accuracy.
In practice, the timestep size insensitivity of a solution is often interpreted as temporal convergence.
This apparent temporal convergence, or timestep size insensitivity, of the solution may not be a result of reaching the solution to the discretized nonlinear equations, but instead could be indicative of the degraded order of accuracy due to the failure to resolve the nonlinearities at each timestep.
To determine if the timestep size insensitive transient solution is both timestep size insensitive and an accurate solution to the nonlinear problem, it is necessary to examine the nonlinear convergence of the system as an issue separate from the temporal-convergence.

The norm of the scaled residual from \sect{sect:nlnScaling} provides a well-scaled metric for instantaneous nonlinear convergence at any given time in the simulation.
The residual vector norm is divided by the number of equations in the residual to provide an average residual value per equation.
This equation-averaged scaled residual provides a metric for determining the degree of nonlinear convergence at any timestep in the simulation.
The natural extension of this metric to transient problems would be a temporal integral, \eqref{eqn:metricResidualIntegral}, of said norm.

\begin{equation}
\label{eqn:metricResidualIntegral}
R = \int_{t^{0}}^{t^{N}} ||\vec{F}(\tau)||_2 \,\mathrm{d} \tau
\end{equation}

Given the bounds of the scaled residual it was considered desirable to have a similarly scaled transient residual.
The transient residual in \eqref{eqn:metricResidualIntegral} possesses a dependence upon the number of timesteps taken.
To remove this dependence, a temporal average was instead investigated, \eqref{eqn:metricResidualAverage}.

\begin{equation}
\label{eqn:metricResidualAverage}
\tilde{R} = \frac{\int_{t^{0}}^{t^{N}} ||\vec{F}(\tau)||_2 \,\mathrm{d} \tau}{t^{N} - t^{0}}
\end{equation}

This metric possesses the desirable bounds $0 \leq R \leq 1$.
Other weighted temporal integrals were considered, such as a simple moment about $t^{0}$, \eqref{eqn:metricResidualMoment}.
However, this moment has the disadvantage of weighting the latter portion of the transient greater than the early portion.

\begin{equation}
\label{eqn:metricResidualMoment}
\tilde{R}_{\text{M}} = \frac{\int_{t^{0}}^{t^{N}} \,\tau\,||\vec{F}(\tau)||_2 \,\mathrm{d} \tau}{\int_{t^{0}}^{t^{N}} \,\tau \,\mathrm{d} \tau}
\end{equation}